
\chapter{The \texttt{methods} package}
\inputencoding{latin1}
\HeaderA{methods-package}{Formal Methods and Classes}{methods.Rdash.package}
\keyword{package}{methods-package}
\keyword{methods}{methods-package}
%
\begin{Description}\relax
Formally defined methods and classes for R objects, plus
other programming tools, as described in the references.
\end{Description}
%
\begin{Details}\relax
This package provides the `S4' or `S version 4' 
approach to methods and classes in a functional language.

See the documentation entries \code{\LinkA{Classes}{Classes}},
\code{\LinkA{Methods}{Methods}}, and \code{\LinkA{GenericFunctions}{GenericFunctions}} for general discussion of these topics, at a
fairly technical level.  Links from those pages, and the
documentation of \code{\LinkA{setClass}{setClass}} and \code{\LinkA{setMethod}{setMethod}}
cover the main programming tools needed.

For a complete
list of functions and classes, use \code{library(help="methods")}.
\end{Details}
%
\begin{Author}\relax
R Development Core Team

Maintainer: R Core Team \email{R-core@r-project.org}
\end{Author}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.) 
\end{References}
\inputencoding{latin1}
\HeaderA{.BasicFunsList}{List of Builtin and Special Functions}{.BasicFunsList}
\keyword{programming}{.BasicFunsList}
\keyword{methods}{.BasicFunsList}
%
\begin{Description}\relax
A named list providing instructions for turning builtin and special
functions into generic functions.

Functions in R that are defined as \code{.Primitive(<name>)} are not
suitable for formal methods, because they lack the basic reflectance
property.  You can't find the argument list for these functions by
examining the function object itself.

Future versions of R may fix this by attaching a formal argument list
to the corresponding function.  While generally the names of arguments
are not checked by the internal code implementing the function, the
number of arguments frequently is.

In any case, some definition of a formal argument list is needed if
users are to define methods for these functions.  In particular, if
methods are to be merged from multiple packages, the different sets
of methods need to agree on the formal arguments.

In the absence of reflectance, this list provides the relevant
information  via a dummy function associated with each of the known
specials for which methods are allowed.

At the same, the list flags those specials for which methods are
meaningless (e.g., \code{for}) or just a very bad idea (e.g.,
\code{.Primitive}).

A generic function created via \code{\LinkA{setMethod}{setMethod}}, for
example, for one of these special functions will have the argument
list from \code{.BasicFunsList}.  If no entry exists, the argument
list \code{(x, ...)}  is assumed.
\end{Description}
\inputencoding{latin1}
\HeaderA{as}{Force an Object to Belong to a Class}{as}
\aliasA{as<\Rdash}{as}{as<.Rdash.}
\aliasA{coerce}{as}{coerce}
\aliasA{coerce,ANY,array-method}{as}{coerce,ANY,array.Rdash.method}
\aliasA{coerce,ANY,call-method}{as}{coerce,ANY,call.Rdash.method}
\aliasA{coerce,ANY,character-method}{as}{coerce,ANY,character.Rdash.method}
\aliasA{coerce,ANY,complex-method}{as}{coerce,ANY,complex.Rdash.method}
\aliasA{coerce,ANY,environment-method}{as}{coerce,ANY,environment.Rdash.method}
\aliasA{coerce,ANY,expression-method}{as}{coerce,ANY,expression.Rdash.method}
\aliasA{coerce,ANY,function-method}{as}{coerce,ANY,function.Rdash.method}
\aliasA{coerce,ANY,integer-method}{as}{coerce,ANY,integer.Rdash.method}
\aliasA{coerce,ANY,list-method}{as}{coerce,ANY,list.Rdash.method}
\aliasA{coerce,ANY,logical-method}{as}{coerce,ANY,logical.Rdash.method}
\aliasA{coerce,ANY,matrix-method}{as}{coerce,ANY,matrix.Rdash.method}
\aliasA{coerce,ANY,name-method}{as}{coerce,ANY,name.Rdash.method}
\aliasA{coerce,ANY,NULL-method}{as}{coerce,ANY,NULL.Rdash.method}
\aliasA{coerce,ANY,numeric-method}{as}{coerce,ANY,numeric.Rdash.method}
\aliasA{coerce,ANY,single-method}{as}{coerce,ANY,single.Rdash.method}
\aliasA{coerce,ANY,ts-method}{as}{coerce,ANY,ts.Rdash.method}
\aliasA{coerce,ANY,vector-method}{as}{coerce,ANY,vector.Rdash.method}
\aliasA{coerce-methods}{as}{coerce.Rdash.methods}
\aliasA{coerce<\Rdash}{as}{coerce<.Rdash.}
\aliasA{setAs}{as}{setAs}
\keyword{programming}{as}
\keyword{classes}{as}
\keyword{methods}{as}
%
\begin{Description}\relax
These functions manage the relations that allow coercing an object to
a given class.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
as(object, Class, strict=TRUE, ext)

as(object, Class) <- value

setAs(from, to, def, replace, where = topenv(parent.frame()))

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] any \R{} object.
\item[\code{Class}] the name of the class to which \code{object} should be
coerced. 
\item[\code{strict}] logical flag.  If \code{TRUE}, the returned object
must be strictly from the target class (unless that class is a
virtual class, in which case the object will be from the closest
actual class, in particular the original object, if that class extends the
virtual class directly).

If \code{strict = FALSE}, any simple extension of the target class
will be returned, without further change.  A simple extension is,
roughly, one that just adds slots to an existing class.
\item[\code{value}] The value to use to modify \code{object} (see the
discussion below).  You should supply an object with class
\code{Class}; some coercion is done, but you're unwise to rely on
it.

\item[\code{from, to}] The classes between which the coerce methods
\code{def} and \code{replace} perform coercion.

\item[\code{def}] function of one argument.  It will get an object from
class \code{from} and had better return an object of class
\code{to}. The convention is that
the name of the argument is \code{from}; if another argument name
is used, \code{setAs} will attempt to substitute \code{from}. 
\item[\code{replace}] if supplied, the function to use as a replacement
method, when \code{as} is used on the left of an assignment.
Should be a function of two arguments, \code{from, value},
although \code{setAs} will attempt to substitute if the arguments differ.
\item[\code{where}] the position or environment in which to store the
resulting methods. For most applications, it is recommended to
omit this argument and to include the call to \code{setAs} in source code that is evaluated at the top level; that is, either in an R session by something equivalent to a call to \code{\LinkA{source}{source}}, or as part of the R source code for a package.
\item[\code{ext}] the optional object
defining how \code{Class} is extended by the class of the
object (as returned by \code{\LinkA{possibleExtends}{possibleExtends}}).
This argument is used internally (to provide essential
information for non-public classes), but you are unlikely to want
to use it directly.

\end{ldescription}
\end{Arguments}
%
\begin{Section}{Summary of Functions}
\begin{description}

\item[\code{as}:] 
Returns the version of this object coerced to be the given
\code{Class}.  When used in the replacement form on the left of
an assignment, the portion of the object corresponding to
\code{Class} is replaced by \code{value}.

The operation of \code{as()} in either form depends on the
definition of coerce methods.  Methods are defined automatically
when the two classes are related by inheritance; that is, when
one of the classes is a subclass of the other.  See the section
on inheritance  below for details.

Coerce methods are also predefined for basic classes (including all
the types of vectors, functions and a few others). See
\code{showMethods(coerce)} for a list of these.

Beyond these two sources of methods, further methods are defined
by calls to the \code{setAs} function.



\item[\code{setAs}:] 
Define methods for coercing an object of class \code{from} to be of class \code{to}; the \code{def} argument provides for direct coercing and the \code{replace} argument, if included, provides for replacement.  See the ``How'' section below for details.


\item[\code{coerce}, \code{coerce<-}:] 
Coerce \code{from} to be of the same class as \code{to}.

These functions should not be called explicitly.  The function
\code{\LinkA{setAs}{setAs}} creates methods for them for the
\code{as} function to use.



\end{description}

\end{Section}
%
\begin{Section}{Inheritance and Coercion}

Objects from one class can turn into objects from another class
either automatically or by an explicit call to the \code{as}
function.  Automatic conversion is special, and comes from the
designer of one class of objects asserting that this class extends
another class.  The most common case is that one or more class names
are supplied in the \code{contains=} argument to \code{setClass}, in
which case the new class extends each of the earlier classes (in the
usual terminology, the earlier classes are \emph{superclasses} of
the new class and it is a \emph{subclass} of each of them).

This form of inheritance is called \emph{simple} inheritance in \R{}.
See \code{\LinkA{setClass}{setClass}} for details.
Inheritance can also be defined explicitly by a call to
\code{\LinkA{setIs}{setIs}}.
The two versions have slightly different implications for coerce methods.
Simple inheritance implies that inherited slots behave identically in the subclass and the superclass.
Whenever two classes are related by simple inheritance, corresponding coerce methods
are defined for both direct and replacement use of \code{as}.
In the case of simple inheritance, these methods do the obvious
computation:  they extract or replace the slots in the object that
correspond to those in the superclass definition.

The implicitly defined coerce methods may be overridden by a call
to \code{setAs}; note, however, that the implicit methods are defined for each
subclass-superclass pair, so that you must override each of these
explicitly, not rely on inheritance.

When inheritance is defined by a call to \code{setIs}, the coerce methods are provided explicitly, not generated automatically.
Inheritance will apply (to the \code{from} argument, as described in  the section below).
You could also supply methods via \code{setAs} for non-inherited relationships, and now these also can be inherited.

For further on the distinction between simple and explicit inheritance, see \code{\LinkA{setIs}{setIs}}.

\end{Section}
%
\begin{Section}{How Functions 'as' and 'setAs' Work}
The function \code{as}  turns \code{object} into an object
of class \code{Class}.  In doing so, it applies a ``coerce
method'', using S4
classes and methods, but in a somewhat special way.
Coerce methods are methods for the function \code{coerce} or, in the
replacement case the function \code{`coerce<-`}.
These functions have two arguments in method signatures, \code{from}
and \code{to}, corresponding to the class of the object and the
desired coerce class.
These functions must not be called directly, but are used to store
tables of methods for the use of \code{as}, directly and for
replacements.
In this section we will describe the direct case, but except where
noted the replacement case works the same way, using \code{`coerce<-`}
and the \code{replace} argument to \code{setAs}, rather than
\code{coerce} and the \code{def} argument.

Assuming the \code{object} is not already of the desired class,
\code{as} first looks for a method in the table of methods
for the function
\code{coerce} for the signature \code{c(from = class(object), to =
    Class)}, in the same way method selection would do its initial lookup.
To be precise, this means the table of both direct and inherited
methods, but inheritance is used specially in this case (see below).

If no method is found, \code{as} looks for one.
First, if either \code{Class} or \code{class(object)} is a superclass
of the other, the class definition will contain the information needed
to construct a coerce method.
In the usual case that the subclass contains the superclass (i.e., has
all its slots), the method is constructed either by extracting or
replacing the inherited slots.
Non-simple extensions (the result of a call to \code{\LinkA{setIs}{setIs}})
will usually contain explicit methods, though possibly not for replacement. 

If no subclass/superclass relationship provides a method, \code{as}
looks for an inherited method, but applying, inheritance for the argument \code{from} only, not for
the argument \code{to} (if you think about it, you'll probably agree
that you wouldn't want the result to be from some class other than the
\code{Class} specified). Thus,
\code{selectMethod("coerce", sig, useInherited= c(from=TRUE, to= FALSE))}
replicates the method selection used by \code{as()}.

In nearly all cases the method found in this way will be cached in the
table of coerce methods (the exception being subclass relationships with a test, which
are legal but discouraged).
So the detailed calculations should be done only on the first
occurrence of a coerce from \code{class(object)} to \code{Class}.

With this explanation as background, the function \code{setAs} does a
fairly obvious computation:  It constructs and sets a method for the function
\code{coerce} with signature \code{c(from, to)}, using the \code{def}
argument to define the body of the method.  The function supplied as
\code{def} can have one argument (interpreted as an object to be
coerced) or two arguments (the \code{from} object and the \code{to}
class).  Either way, \code{setAs} constructs a function of two
arguments, with the second defaulting to the name of the \code{to}
class.  The method will be called from \code{as} with the object
as the \code{from} argument and no \code{to} argument, with the default for this argument being the name of the intended
\code{to} class, so the method can use this information in messages.

The direct version of the \code{as} function also has a \code{strict=} argument that defaults to \code{TRUE}.
Calls during the evaluation of methods for other functions will set this argument to \code{FALSE}.
The distinction is relevant when the object being coerced is from a simple subclass of the \code{to} class; if \code{strict=FALSE} in this case, nothing need be done.
For most user-written coerce methods, when the two classes have no subclass/superclass, the \code{strict=} argument is irrelevant.

The \code{replace} argument to \code{setAs} provides a method for
\code{`coerce<-`}.
As with all replacement methods, the last argument of the method must
have the name \code{value} for the object on the right of the
assignment.
As with the \code{coerce} method, the first two arguments are
\code{from, to}; there is no \code{strict=} option for the replace case.

The function \code{coerce} exists as a repository for
such methods, to be selected as described above by the \code{as}
function.  Actually dispatching the methods using
\code{standardGeneric} could produce incorrect inherited methods, by using
inheritance on the
\code{to} argument; as mentioned, this is not the logic used for
\code{as}.
To prevent selecting and caching invalid methods, calls to
\code{coerce} are
currently mapped into calls to \code{as}, with a warning message.
\end{Section}
%
\begin{Section}{Basic Coercion Methods}
Methods are pre-defined for coercing any object to one of the basic
datatypes.  For example, \code{as(x, "numeric")} uses the existing
\code{as.numeric} function.  These built-in methods can be listed by
\code{showMethods("coerce")}.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
If you think of using \code{try(as(x, cl))}, consider
\code{\LinkA{canCoerce}{canCoerce}(x, cl)} instead.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## using the definition of class "track" from \link{Classes}



setAs("track", "numeric", function(from) from@y)

t1 <- new("track", x=1:20, y=(1:20)^2)

as(t1, "numeric")

## The next example shows:
##  1. A virtual class to define setAs for several classes at once.
##  2. as() using inherited information

setClass("ca", representation(a = "character", id = "numeric"))

setClass("cb", representation(b = "character", id = "numeric"))

setClass("id")
setIs("ca", "id")
setIs("cb", "id")


setAs("id", "numeric", function(from) from@id)

CA <- new("ca", a = "A", id = 1)
CB <- new("cb", b = "B", id = 2)

setAs("cb", "ca", function(from, to )new(to, a=from@b, id = from@id))

as(CB, "numeric")


\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{BasicClasses}{Classes Corresponding to Basic Data Types}{BasicClasses}
\aliasA{ANY-class}{BasicClasses}{ANY.Rdash.class}
\aliasA{character-class}{BasicClasses}{character.Rdash.class}
\aliasA{complex-class}{BasicClasses}{complex.Rdash.class}
\aliasA{double-class}{BasicClasses}{double.Rdash.class}
\aliasA{expression-class}{BasicClasses}{expression.Rdash.class}
\aliasA{externalptr-class}{BasicClasses}{externalptr.Rdash.class}
\aliasA{function-class}{BasicClasses}{function.Rdash.class}
\aliasA{integer-class}{BasicClasses}{integer.Rdash.class}
\aliasA{list-class}{BasicClasses}{list.Rdash.class}
\aliasA{logical-class}{BasicClasses}{logical.Rdash.class}
\aliasA{missing-class}{BasicClasses}{missing.Rdash.class}
\aliasA{NULL-class}{BasicClasses}{NULL.Rdash.class}
\aliasA{numeric-class}{BasicClasses}{numeric.Rdash.class}
\aliasA{raw-class}{BasicClasses}{raw.Rdash.class}
\aliasA{S4-class}{BasicClasses}{S4.Rdash.class}
\aliasA{single-class}{BasicClasses}{single.Rdash.class}
\aliasA{vector-class}{BasicClasses}{vector.Rdash.class}
\aliasA{VIRTUAL-class}{BasicClasses}{VIRTUAL.Rdash.class}
\keyword{classes}{BasicClasses}
%
\begin{Description}\relax
Formal classes exist corresponding to the basic R object types, allowing
these types to be used in method signatures, as slots in class
definitions, and to be extended by new classes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
### The following are all basic vector classes.
### They can appear as class names in method signatures,
### in calls to as(), is(), and new().
"character"
"complex"
"double"
"expression"
"integer"
"list"
"logical"
"numeric"
"single"
"raw"

### the class
"vector"
### is a virtual class, extended by all the above

### the class
"S4"
### is an object type for S4 objects that do not extend
### any of the basic vector classes.  It is a virtual class.

### The following are additional basic classes
"NULL"     #  NULL objects
"function" #  function objects, including primitives
"externalptr" # raw external pointers for use in C code

"ANY"  # virtual classes used by the methods package itself
"VIRTUAL"
"missing"
\end{verbatim}
\end{Usage}
%
\begin{Section}{Objects from the Classes}
Objects can be created by calls of the form \code{new(Class, ...)},
where \code{Class} is the quoted class name, and the remaining
arguments if any are objects to be interpreted as vectors of this
class.  Multiple arguments will be concatenated.

The class \code{"expression"} is slightly odd, in that the \dots
arguments will \emph{not} be evaluated; therefore, don't enclose them
in a call to \code{quote()}.
\end{Section}
%
\begin{Section}{Extends}
Class \code{"vector"}, directly.
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[coerce] Methods are defined to coerce arbitrary objects to
these classes, by calling the corresponding basic function, for
example, \code{as(x, "numeric")} calls \code{as.numeric(x)}. 

\end{description}

\end{Section}
\inputencoding{latin1}
\HeaderA{callGeneric}{Call the Current Generic Function from a Method}{callGeneric}
\keyword{programming}{callGeneric}
\keyword{classes}{callGeneric}
\keyword{methods}{callGeneric}
%
\begin{Description}\relax
A call to \code{callGeneric} can only appear inside a method
definition.  It then results in a call to the current generic
function.  The value of that call is the value of \code{callGeneric}.
While it can be called from any method, it is useful and typically
used in methods for group generic functions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
callGeneric(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] 
Optionally, the arguments to the function in its next call.

If no arguments are included in the call to \code{callGeneric}, the
effect is to call the function with the current arguments.
See the detailed description for what this really means.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The name and package of the current generic function is stored in the
environment of the method definition object.  This name is looked up
and the corresponding function called.

The statement that passing no arguments to \code{callGeneric} causes
the generic  function to be called with the current arguments is
more precisely as follows.  Arguments that were missing in the current
call are still missing (remember that \code{"missing"} is a valid
class in a method signature).  For a formal argument, say \code{x}, that
appears in the original call, there is a corresponding argument in the
generated call equivalent to \code{x = x}.  In effect, this
means that the generic function sees the same actual arguments, but
arguments are evaluated only once.

Using \code{callGeneric} with no arguments is prone to creating
infinite recursion, unless one of the arguments in the signature has
been modified in the current method so that a different method is selected.
\end{Details}
%
\begin{Value}
The value returned by the new call.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{GroupGenericFunctions}{GroupGenericFunctions}} for other information
about group generic functions; \LinkA{Methods}{Methods} for the general behavior
of method dispatch
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## the method for group generic function Ops
## for signature( e1="structure", e2="vector")
function (e1, e2)
{
    value <- callGeneric(e1@.Data, e2)
    if (length(value) == length(e1)) {
        e1@.Data <- value
        e1
    }
    else value
}

## For more examples
## Not run: 
showMethods("Ops", includeDefs = TRUE)

## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{callNextMethod}{Call an Inherited Method}{callNextMethod}
\keyword{programming}{callNextMethod}
\keyword{classes}{callNextMethod}
\keyword{methods}{callNextMethod}
%
\begin{Description}\relax
A call to \code{callNextMethod} can only appear inside a method
definition.  It then results in a call to the first inherited method
after the current method, with the arguments to the current method
passed down to the next method.  The value of that method call is the
value of \code{callNextMethod}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
callNextMethod(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] 
Optionally, the arguments to the function in its next call
(but note that the dispatch is as in the detailed description below;
the arguments have no effect on selecting the next method.)

If no arguments are included in the call to \code{callNextMethod}, the
effect is to call the method with the current arguments.
See the detailed description for what this really means.

Calling with no arguments is often the natural way to use
\code{callNextMethod}; see the examples.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The `next' method (i.e., the first inherited method) is defined
to be that method which \emph{would} have been called if the current
method did not exist. This is more-or-less literally what happens: The
current method (to be precise, the method with signature given by the
\code{defined} slot of the method from which \code{callNextMethod} is
called) is deleted from a copy of the methods for the current generic,
and \code{\LinkA{selectMethod}{selectMethod}} is called to find the next method (the
result is cached in a special object, so the search only typically
happens once per session per combination of argument classes).

Note that the preceding definition means that the next method is
defined uniquely when \code{setMethod} inserts the method containing
the \code{callNextMethod} call, given the definitions of the classes
in the signature. The choice does not depend on the path that gets us
to that method (for example, through inheritance or from another
\code{callNextMethod} call). This definition was not enforced in
versions of \R{} prior to 2.3.0, where the method was selected based on
the target signature, and so could vary depending on the actual
arguments.

It is also legal, and often useful, for the method called by
\code{callNextMethod} to itself have a call to
\code{callNextMethod}. This generally works as you would expect, but
for completeness be aware that it is possible to have ambiguous
inheritance in the S structure, in the sense that the same two
classes can appear as superclasses \emph{in the opposite order} in
two other class definitions.  In this case the effect of a nested
instance of \code{callNextMethod} is not well defined.  Such
inconsistent class hierarchies are both rare and nearly always the
result of bad design, but they are possible, and currently undetected.

The statement that the method is called with the current arguments is
more precisely as follows.  Arguments that were missing in the current
call are still missing (remember that \code{"missing"} is a valid
class in a method signature).  For a formal argument, say \code{x}, that
appears in the original call, there is a corresponding argument in the
next method call equivalent to \code{x = x}.  In effect, this
means that the next method sees the same actual arguments, but
arguments are evaluated only once.
\end{Details}
%
\begin{Value}
The value returned by the selected method.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.) 
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{callGeneric}{callGeneric}} to call the generic function with the current
dispatch rules (typically for a group generic function); \LinkA{Methods}{Methods} for the general behavior of method dispatch
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

## some class definitions with simple inheritance
setClass("B0" , representation(b0 = "numeric"))

setClass("B1", representation(b1 = "character"), contains = "B0")

setClass("B2", representation(b2 = "logical"), contains = "B1")

## and a rather silly function to illustrate callNextMethod

f <- function(x) class(x)

setMethod("f", "B0", function(x) c(x@b0^2, callNextMethod()))
setMethod("f", "B1", function(x) c(paste(x@b1,":"), callNextMethod()))
setMethod("f", "B2", function(x) c(x@b2, callNextMethod()))

b1 <- new("B1", b0 = 2, b1 = "Testing")

b2 <- new("B2", b2 = FALSE, b1 = "More testing", b0 = 10)

f(b2)
stopifnot(identical(f(b2), c(b2@b2, paste(b2@b1,":"), b2@b0^2, "B2")))

f(b1)

## a sneakier method: the *changed* x is used:
setMethod("f", "B2", function(x) {x@b0 <- 111; c(x@b2, callNextMethod())})
f(b2)
stopifnot(identical(f(b2), c(b2@b2, paste(b2@b1,":"), 111^2, "B2")))



\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{canCoerce}{Can an Object be Coerced to a Certain S4 Class?}{canCoerce}
\keyword{classes}{canCoerce}
\keyword{methods}{canCoerce}
%
\begin{Description}\relax
Test if an object can be coerced to a given S4 class.
Maybe useful inside \code{if()} to ensure that calling
\code{as(object, Class)} will find a method.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
canCoerce(object, Class)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] any \R{} object, typically of a formal S4 class.
\item[\code{Class}] an S4 class (see \code{\LinkA{isClass}{isClass}}).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a scalar logical, \code{TRUE} if there is a \code{coerce} method
(as defined by \code{\LinkA{setAs}{setAs}}, e.g.) for the signature
\code{(from = class(object), to = Class)}.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{as}{as}}, \code{\LinkA{setAs}{setAs}},
\code{\LinkA{selectMethod}{selectMethod}}, \code{\LinkA{setClass}{setClass}},
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
m <- matrix(pi, 2,3)
canCoerce(m, "numeric") # TRUE
canCoerce(m, "array")   # TRUE
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{cbind2}{Combine two Objects by Columns or Rows}{cbind2}
\aliasA{cbind2,ANY,ANY-method}{cbind2}{cbind2,ANY,ANY.Rdash.method}
\aliasA{cbind2,ANY,missing-method}{cbind2}{cbind2,ANY,missing.Rdash.method}
\aliasA{cbind2-methods}{cbind2}{cbind2.Rdash.methods}
\aliasA{rbind2}{cbind2}{rbind2}
\aliasA{rbind2,ANY,ANY-method}{cbind2}{rbind2,ANY,ANY.Rdash.method}
\aliasA{rbind2,ANY,missing-method}{cbind2}{rbind2,ANY,missing.Rdash.method}
\aliasA{rbind2-methods}{cbind2}{rbind2.Rdash.methods}
\keyword{array}{cbind2}
\keyword{manip}{cbind2}
%
\begin{Description}\relax
Combine two matrix-like \R{} objects by columns (\code{cbind2})
or rows (\code{rbind2}). These are (S4) generic functions with default
methods.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
cbind2(x, y)
rbind2(x, y)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] any \R{} object, typically matrix-like.
\item[\code{y}] any \R{} object, typically similar to \code{x}, or missing
completely.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The main use of \code{cbind2} (\code{rbind2}) is to be called by
\code{\LinkA{cbind}{cbind}()}  (\code{rbind()})
\bold{if} these are activated.  This allows \code{cbind}
(\code{rbind}) to work for formally classed (aka `S4')
objects by providing S4 methods for these objects.  Currently, a call\\{}
\code{methods:::bind\_activation(TRUE)}\\{}
is needed to install a
\code{cbind2}-calling version of \code{cbind} (into the
\pkg{base} name space) and the same for \code{rbind}.\\{}
\code{methods:::bind\_activation(FALSE)} reverts to the
previous internal version of \code{cbind} which does not build on
\code{cbind2}, see the examples.
\end{Details}
%
\begin{Value}
A matrix (or matrix like object) combining the columns (or rows) of
\code{x} and \code{y}.
\end{Value}
%
\begin{Section}{Methods}
\begin{description}

\item[\code{signature(x = "ANY", y = "ANY")}] the default method
using \R{}'s internal code.
\item[\code{signature(x = "ANY", y = "missing")}] the default method
for one argument using \R{}'s internal code.

\end{description}

\end{Section}
%
\begin{SeeAlso}\relax
\code{\LinkA{cbind}{cbind}}, \code{\LinkA{rbind}{rbind}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
cbind2(1:3, 4)
m <- matrix(3:8, 2,3, dimnames=list(c("a","b"), LETTERS[1:3]))
cbind2(1:2, m) # keeps dimnames from m

### Note: Use the following activation if you want cbind() to work
### ----  on S4 objects -- be careful otherwise!

methods:::bind_activation(on = TRUE)
trace("cbind2")
cbind(a=1:3)# no call to cbind2()
cbind(a=1:3, four=4, 7:9)# calling cbind2() twice
untrace("cbind2")



## The following fails currently,
## since cbind() works recursively from the tail:
try( cbind(m, a=1, b=3) )

## turn off the `special cbind()' :
methods:::bind_activation(FALSE)
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{Classes}{Class Definitions}{Classes}
\aliasA{.environment-class}{Classes}{.environment.Rdash.class}
\aliasA{.externalptr-class}{Classes}{.externalptr.Rdash.class}
\aliasA{.name-class}{Classes}{.name.Rdash.class}
\aliasA{.NULL-class}{Classes}{.NULL.Rdash.class}
\aliasA{\_\_ClassMetaData}{Classes}{.Rul..Rul.ClassMetaData}
\keyword{programming}{Classes}
\keyword{classes}{Classes}
\keyword{methods}{Classes}
%
\begin{Description}\relax
Class definitions are objects that contain the formal definition of a
class of \R{} objects, usually referred to as an S4 class, to
distinguish them from the informal S3 classes.
This document gives an overview of S4 classes; for
details of the class representation objects, see help for the class
\code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}.
\end{Description}
%
\begin{Section}{Metadata Information}
When a class is defined, an object is stored that contains the
information about that class.  The object, known as the
\emph{metadata} defining the class, is not stored under the name of
the class (to allow programmers to write generating functions of
that name), but under a specially constructed name.
To examine the class definition, call \code{\LinkA{getClass}{getClass}}.  The
information in the metadata object includes:

\begin{description}

\item[Slots:] 

The data contained in an object from an S4 class is defined by
the \emph{slots} in the class definition.

Each slot in an object is a component of the object;
like components (that is, elements) of a
list, these may be extracted and set, using the
function \code{\LinkA{slot}{slot}()} or more often the operator
\code{"\LinkA{@}{@}"}.  However, they
differ from list components in important ways.
First, slots can only be referred to by name, not by position,
and there is no partial matching of names as with list elements.

All the objects from a particular class have the same set of slot
names; specifically, the slot names that are contained in the
class definition.  Each slot in each object always is an object
of  the
class specified for this slot in the definition of the current class.
The word ``is'' corresponds to the \R{} function of the same
name (\code{\LinkA{is}{is}}), meaning that the class of the object in
the slot must be the same as the class specified in the
definition, or some class that extends the one in the
definition (a \emph{subclass}).

One slot name is special, \code{.Data}.  This stands for the
`data part' of the object.  An object from a class with a
data part is defined by specifying that the class contains one
of the \R{} object types or one of the special pseudo-classes, 
\code{matrix} or \code{array}, usually because the definition of
the class, or of one of its superclasses, has included the type
or pseudo-class in its \code{contains} argument.  See the
section on inheriting from non-S4 classes for more details.


\item[Superclasses:] 

The definition of a class includes the \emph{superclasses} ---the classes that this class extends.  A
class \code{Fancy}, say, extends a class \code{Simple} if an
object from the \code{Fancy} class has all the capabilities of
the \code{Simple} class (and probably some more as well).  In
particular, and very usefully, any method defined to work for a
\code{Simple} object can be applied to a \code{Fancy} object as
well.

This relationship is
expressed equivalently by saying that \code{Simple} is a superclass of
\code{Fancy}, or that \code{Fancy} is a subclass of
\code{Simple}.

The direct superclasses of a class are those superclasses
explicitly defined.   Direct superclasses can be defined in
three ways.  Most commonly, the superclasses are listed in the
\code{contains=} argument in the call to \code{\LinkA{setClass}{setClass}}
that creates the subclass.   In this case the subclass will
contain all the slots of the superclass, and the relation
between the class is called \emph{simple}, as it in fact is.
Superclasses can also be defined
explicitly by a call to \code{\LinkA{setIs}{setIs}}; in this case, the
relation requires methods to be specified to go from subclass to
superclass.   Thirdly, a class union is a superclass of all the
members of the union.  In this case too the relation is simple,
but notice that the relation is defined when the superclass is
created, not when the subclass is created as with the
\code{contains=} mechanism.

The definition of a superclass will also potentially contain
its own direct superclasses.  These are considered (and shown) as
superclasses at distance 2 from the original class; their direct
superclasses are at distance 3, and so on.  All these are
legitimate superclasses for purposes such as method selection.

When superclasses are defined  by including the names of
superclasses in the \code{contains=} argument to
\code{\LinkA{setClass}{setClass}},   an object from the class will have all the slots
defined for its own class \emph{and} all the slots defined for all
its superclasses as well.

The information about the relation between a class and a
particular superclass is encoded as an object of class
\code{\LinkA{SClassExtension}{SClassExtension.Rdash.class}}.  A list of such objects for
the superclasses (and sometimes for the subclasses) is included in
the metadata object defining the class.  If you need to compute
with these objects (for example, to compare the distances), call
the function \code{\LinkA{extends}{extends}} with argument \code{fullInfo=TRUE}.


\item[Prototype:] 

The objects from a class created by a call to
\code{\LinkA{new}{new}}
are defined by the \emph{prototype} object for the class and by
additional arguments in the call to \code{\LinkA{new}{new}}, which are
passed to a method for that class for the function
\code{\LinkA{initialize}{initialize}}.

Each class representation object contains a prototype object
for the class (although for a virtual class the prototype may be
\code{NULL}). The prototype object must have values for all the
slots of the class.
By default, these are the prototypes of
the corresponding slot classes.  However, the
definition of the class can specify any valid object for any of
the slots.


\end{description}

\end{Section}
%
\begin{Section}{Virtual classes; Basic classes}

Classes exist for which no actual objects can be created by a
call to \code{\LinkA{new}{new}}, the
\emph{virtual} classes, in fact a
very important programming tool.  They are used to group together
ordinary classes that want to share some programming behavior,
without necessarily restricting how the behavior is implemented.
Virtual class definitions may if you want include
slots (to provide some common behavior without fully defining
the object---see the class \code{\LinkA{traceable}{traceable.Rdash.class}} for an example).

A simple and useful form of virtual class is the \emph{class
union}, a virtual class that is defined in a call to
\code{\LinkA{setClassUnion}{setClassUnion}} by listing one or
more of subclasses (classes that extend the class union).  Class
unions can include as subclasses basic object types (whose
definition is otherwise sealed).

There are a number of `basic' classes, corresponding to the
ordinary kinds of data occurring in R.  For example,
\code{"numeric"} is a class corresponding to numeric vectors.
The other vector basic classes are \code{"logical"}, \code{"integer"}, 
\code{"complex"}, \code{"character"},  \code{"raw"}, \code{"list"}
and \code{"expression"}.
The prototypes for
the vector classes are vectors of length 0 of the corresponding
type.  Notice that basic classes are unusual in that the
prototype object is from the class itself.

In addition to the vector classes there are also basic classes corresponding to objects in the
language, such as \code{"function"} and \code{"call"}.
These classes are subclasses of the virtual class \code{"language"}.
Finally, there are object types and corresponding basic classes for
``abnormal'' objects, such as \code{"environment"} and
\code{"externalptr"}.
These objects do not follow the
functional behavior of the language; in particular, they are not
copied and so cannot have attributes or slots defined locally.

All these classes can be used as slots or as
superclasses for any other class definitions, although they do
not themselves come with an explicit class.  For the abnormal
object types, a special mechanism is used to enable inheritance
as described below.


\end{Section}
%
\begin{Section}{Inheriting from non-S4 Classes}
A class definition can extend classes other than
regular S4 classes, usually by specifying them in the
\code{contains=} argument to \code{\LinkA{setClass}{setClass}}.  Three groups
of such classes behave distinctly:
\begin{enumerate}

\item 
S3 classes, which must have been registered by a previous call to
\code{\LinkA{setOldClass}{setOldClass}} (you can check that this has been done
by calling \code{\LinkA{getClass}{getClass}}, which should return a class that
extends \LinkA{oldClass}{oldClass.Rdash.class});

\item 
One of the \R{} object types, typically a vector type, which then
defines the type of the S4 objects, but also a type such as
\code{\LinkA{environment}{environment}} that can not be used directly as a type
for an S4 object.  See
below.

\item 
One of the pseudo-classes \code{\LinkA{matrix}{matrix.Rdash.class}}
and \code{\LinkA{array}{array.Rdash.class}}, implying objects with
arbitrary vector types plus the \code{dim} and \code{dimnames}
attributes.

\end{enumerate}


This section describes the approach to combining S4 computations
with older S3 computations by using such classes as superclasses. The
design goal is to allow the S4 class to inherit S3 methods and
default computations in as consistent a form as possible.


As part of a general effort to make the S4 and S3 code in R more
consistent,
when objects from an S4 class are used as the first argument
to a non-default S3 method, either for an S3 generic function (one that calls
\code{\LinkA{UseMethod}{UseMethod}}) or for one of the primitive functions
that dispatches S3 methods, an effort is made to provide a
valid object for that method.  In
particular, if the S4 class extends an S3 class or \code{matrix}
or \code{array}, and there is an S3 method matching one of these
classes, the S4 object will be coerced to a valid S3 object, to
the extent that is possible given that there is no formal
definition of an S3 class.

For example, suppose \code{"myFrame"} is an S4 class that
includes the S3 class \code{"data.frame"} in the \code{contains=}
argument to \code{\LinkA{setClass}{setClass}}.  If an object from this S4
class is passed to a function, say \code{\LinkA{as.matrix}{as.matrix}}, that
has an S3 method for \code{"data.frame"}, the internal code for
\code{\LinkA{UseMethod}{UseMethod}} will convert the object to a data frame;
in particular, to an S3 object whose class attribute will be the vector
corresponding to the S3 class (possibly containing multiple
class names). Similarly for an S4 object inheriting from
\code{"matrix"} or \code{"array"}, the S4 object will be
converted to a valid S3 matrix or array.

Note that the conversion is \emph{not} applied when an S4 object is passed
to the default S3 method.  Some S3 generics attempt
to deal with general objects, including S4 objects.  Also, no transformation is
applied to S4 objects that do not correspond to a
selected S3 method; in particular, to objects from a class that
does not contain either an S3 class or one of the basic types.
See \code{\LinkA{asS4}{asS4}} for the transformation details.

In addition to explicit S3 generic functions, S3 methods are
defined for a variety of operators and functions implemented as
primitives.  These methods are dispatched by some internal C
code that operates partly through the same code as real S3
generic functions and partly via special considerations (for
example, both arguments to a binary operator are examined when
looking for methods).  The same mechanism for adapting S4
objects to S3 methods has been applied to these computations as
well, with a few exceptions such as generating an error if an S4
object that does not extend an appropriate S3 class or type is
passed to a binary operator.

The remainder of this section discusses the mechanisms for
accessing the inherited objects of the second and third items
above:  basic object types and the matrix and array
pseudo-classes.  For the corresponding details for inheritance
from S3 classes, see \code{\LinkA{setOldClass}{setOldClass}}.

An object from a class that directly and simply contains one
of the basic object types in \R{}, has implicitly a corresponding
\code{.Data} slot of that type, allowing computations to extract
or replace the data part while leaving other slots
unchanged. If the type is one that can accept attributes and is
duplicated normally, the inheritance also determines the type of the
object; if the class definition has a \code{.Data} slot
corresponding to a normal type, the class of the
slot determines the type of the object (that is, the value of
\code{\LinkA{typeof}{typeof}(x)}).
For such classes,  \code{.Data} is a pseudo-slot; that 
is, extracting or setting it modifies the non-slot data in the
object.  The functions \code{\LinkA{getDataPart}{getDataPart}} and
\code{\LinkA{setDataPart}{setDataPart}} are a cleaner, but essentially
equivalent way to deal with the data part.

Extending a basic type this way allows objects to
use old-style code for the corresponding type as well as S4
methods.  Any basic type can be used for \code{.Data}, but 
a few types are treated differently because they do not behave like ordinary objects;
for example, \code{"NULL"}, environments, and external pointers.
Classes extend these types by using a specially named slot,
itself inherited from an internally defined S4 class.
Inheritance from the nonstandard object type then requires an
actual computation, rather than the \code{"simple"} inclusion
for other types and classes.  The intent is that programmers
will not need to take account of the mechanism, but one
implication is that you should \emph{not} explicitly use the
type of an S4 object that extends an arbitrary object type.  Use
\code{\LinkA{is}{is}} and similar functions instead.

There is  one additional use of the data part, which is also an
exception to the correspondence with the object's type.  The exception
arises from the special treatment of \code{\LinkA{matrix}{matrix.Rdash.class}}
and \code{\LinkA{array}{array.Rdash.class}} ``classes'' in \R{}.
Matrix and array objects are managed internally and recognized
without regard to any class attribute; therefore, they can be
used as the data part of a new class.  In this case, the object
type for the new class depends on the type of the data in the
matrix or array, but the \code{.Data} slot in the definition
will be \code{"matrix"} or \code{"array"}.

\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.) 

Chambers, John M.  and Hastie, Trevor  J. eds (1992)
\emph{Statistical Models in S.}
Wadsworth \& Brooks/Cole (Appendix A for S3 classes.)

Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
\emph{The New S Language}.
Wadsworth \& Brooks/Cole. (Out of print.) (The description of
vectors, matrix, array and time-series objects.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{Methods}{Methods}} for analogous discussion of methods,
\code{\LinkA{setClass}{setClass}} for details of specifying class definitions,
\code{\LinkA{is}{is}},
\code{\LinkA{as}{as}},
\code{\LinkA{new}{new}},
\code{\LinkA{slot}{slot}}
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{classesToAM}{Compute an Adjacency Matrix for Superclasses of one or more Class Definitions}{classesToAM}
\keyword{classes}{classesToAM}
\keyword{programming}{classesToAM}
%
\begin{Description}\relax
Given a vector of class names or a list of class definitions, the
function returns an adjacency matrix of the superclasses of these
classes; that is, a matrix with class names as the row and column
names and with element [i, j] being 1 if the class in column j is a
direct superclass of the class in row i, and 0 otherwise.

The matrix has the information implied by the \code{contains} slot of
the class definitions, but in a form that is often more convenient for
further analysis; for example, an adjacency matrix is used in packages
and other software to construct graph representations of relationships.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
classesToAM(classes, includeSubclasses = FALSE,
       abbreviate = 2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{classes}] 
Either a character vector of class names or a list, whose
elements can be either class names or class definitions.  The
list is convenient, for example, to include the package slot for
the class name. See the examples.

\item[\code{includeSubclasses}] 
A logical flag; if \code{TRUE}, then the matrix will include all
the known subclasses of the specified classes as well as the
superclasses.  The argument can also be a logical vector of the
same length as \code{classes}, to include subclasses for some
but not all the classes.

\item[\code{abbreviate}] 
Control of the abbreviation of the row and/or  column labels of
the matrix returned: values 0, 1, 2, or 3 abbreviate neither,
rows, columns or both.  The default, 2, is useful for printing
the matrix, since class names tend to be more than one
character long, making for spread-out printing.  Values of 0
or 3 would be appropriate for making a graph (3 avoids the
tendency of some graph plotting software to produce labels in
minuscule font size).

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
For each of the classes, the calculation gets all the superclass
names from the class definition, and finds the edges in those classes'
definitions; that is, all the superclasses at distance 1.  The
corresponding elements of the adjacency matrix are set to 1.

The adjacency matrices for the individual class definitions are
merged.  Note two possible kinds of inconsistency, neither of which
should cause problems except possibly with identically named classes from
different packages.  Edges are computed from each superclass
definition, so that information overrides a possible inference from
extension elements with distance > 1 (and it should).  When
matrices from successive classes in the argument are merged, the
computations do not currently check for inconsistencies---this is
the area where possible multiple classes with the same name could
cause confusion.  A later revision may include consistency checks.
\end{Details}
%
\begin{Value}
As described, a matrix with entries 0 or 1, non-zero values
indicating that the class corresponding to the column is a direct
superclass of the class corresponding to the row.  The row and
column names are the class names (without package slot).
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{extends}{extends}} and \LinkA{classRepresentation}{classRepresentation.Rdash.class} for the underlying information from the class
definition.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

## the super- and subclasses of "standardGeneric" and "derivedDefaultMethod"
am <- classesToAM(list(class(show), class(getMethod(show))), TRUE)
am

## Not run: 
## the following function depends on the Bioconductor package Rgraphviz
plotInheritance <- function(classes, subclasses = FALSE, ...) {
    if(!require("Rgraphviz", quietly=TRUE))
      stop("Only implemented if Rgraphviz is available")
    mm <- classesToAM(classes, subclasses)
    classes <- rownames(mm); rownames(mm) <- colnames(mm)
    graph <-  new("graphAM", mm, "directed", ...)
    plot(graph)
    cat("Key:\n", paste(abbreviate(classes), " = ", classes, ", ",
        sep = ""),  sep = "", fill = TRUE)
    invisible(graph)
}

## The plot of the class inheritance of the package "graph"
require(graph)
plotInheritance(getClasses("package:graph"))


## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{classRepresentation-class}{Class Objects}{classRepresentation.Rdash.class}
\keyword{classes}{classRepresentation-class}
%
\begin{Description}\relax
  These are the objects that hold the definition of
classes of objects.  They are constructed and stored as meta-data by
calls to the function \code{\LinkA{setClass}{setClass}}.  Don't manipulate them
directly, except perhaps to look at individual slots. 
\end{Description}
%
\begin{Details}\relax
Class definitions are stored as metadata in various packages.
Additional metadata supplies information on inheritance (the result of
calls to \code{\LinkA{setIs}{setIs}}).  Inheritance information implied by the
class definition itself (because the class contains one or more other
classes) is also constructed automatically.

When a class is to be used in an R session, this information is
assembled to complete the class definition.  The completion is a
second object of class \code{"classRepresentation"}, cached for the
session or until something happens to change the information.  A call
to \code{\LinkA{getClass}{getClass}} returns the completed definition of a class;
a call to \code{\LinkA{getClassDef}{getClassDef}} returns the stored definition
(uncompleted).

In particular, completion fills in the upward- and downward-pointing
inheritance information for the class, in slots \code{contains} and
\code{subclasses} respectively.  It's in principle important to note
that this information can depend on which packages are installed,
since these may define additional subclasses or superclasses.
\end{Details}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{slots}:] A named list of the slots in this class; the
elements of the list are the classes to which the slots must
belong (or extend), and the names of the list gives the
corresponding slot names.
\item[\code{contains}:] A named list of the classes this class
`contains'; the elements of the list are objects of
\code{\LinkA{SClassExtension}{SClassExtension.Rdash.class}}. The list may be only the
direct extensions or all the currently known extensions (see the
details).
\item[\code{virtual}:] Logical flag, set to \code{TRUE} if this is
a virtual class.
\item[\code{prototype}:] The object that represents the standard
prototype for this class; i.e., the data and slots returned by a
call to \code{\LinkA{new}{new}} for this class with no special
arguments.  Don't mess with the prototype object directly.
\item[\code{validity}:] Optionally, a function to be used to test
the validity of objects from this class.
See \code{\LinkA{validObject}{validObject}}.
\item[\code{access}:] Access control information.  Not currently used.
\item[\code{className}:] The character string name of the class.
\item[\code{package}:] The character string name of the package to
which the class belongs.  Nearly always the package on which the
metadata for the class is stored, but in operations such as
constructing inheritance information, the internal package name
rules.
\item[\code{subclasses}:] A named list of the classes known to
extend this class'; the elements of the list are objects of class
\code{\LinkA{SClassExtension}{SClassExtension.Rdash.class}}.  The list is currently only
filled in when completing the class definition (see the details).
\item[\code{versionKey}:] Object of class \code{"externalptr"};
eventually will perhaps hold some versioning information, but not
currently used. 
\item[\code{sealed}:] Object of class \code{"logical"}; is this
class sealed?  If so, no modifications are allowed. 

\end{description}

\end{Section}
%
\begin{SeeAlso}\relax
See function \code{\LinkA{setClass}{setClass}} to supply the information in the
class definition.
See \LinkA{Classes}{Classes} for a more basic discussion of class information.
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{Documentation}{Using and Creating On-line Documentation for Classes and
 Methods}{Documentation}
\aliasA{Documentation-class}{Documentation}{Documentation.Rdash.class}
\aliasA{Documentation-methods}{Documentation}{Documentation.Rdash.methods}
\keyword{programming}{Documentation}
\keyword{methods}{Documentation}
\keyword{classes}{Documentation}
\keyword{documentation}{Documentation}
%
\begin{Description}\relax
Special documentation can be supplied to describe the
classes and methods that are created by the software in the methods
package.  Techniques to access this documentation and to create it
in R help files are described here.
\end{Description}
%
\begin{Section}{Getting documentation on classes and methods}
You can ask for on-line help for class definitions, for specific
methods for a generic function, and for general discussion of
methods for a generic function.  These requests use the \code{?}
operator (see \code{\LinkA{help}{help}} for a general description of
the operator).  Of course, you are at the mercy of the implementer
as to whether there \emph{is} any documentation on the corresponding
topics.

Documentation on a class uses the argument \code{class} on the left
of the \code{?}, and the name of the class on the right; for
example,

\code{class ? genericFunction}

to ask for documentation on the class \code{"genericFunction"}.

When you want documentation for the methods defined for a particular
function, you can ask either for a general discussion of the methods
or for documentation of a particular method (that is, the method that
would be selected for a particular set of actual arguments).

Overall methods documentation is requested by
calling the \code{?} operator with \code{methods} as the left-side
argument and the name of the function as the right-side argument. For
example,

\code{methods ? initialize}

asks for documentation on the methods for the \code{\LinkA{initialize}{initialize}}
function.

Asking for documentation on a particular method is done by giving a
function call expression as the right-hand argument to the \code{"?"}
operator.  There are two forms, depending on whether you prefer to
give the class names for the arguments or expressions that you intend
to use in the actual call.

If you planned to evaluate a function call, say \code{myFun(x, sqrt(wt))}
and wanted to find out something about the method that would be used
for this call, put the call on the right of the \code{"?"} operator:

\code{?myFun(x, sqrt(wt))}

A method will be selected, as it would be for the call itself, and
documentation for that method will be requested.  If \code{myFun} is
not a generic function, ordinary documentation for the function will
be requested.

If you know the actual classes for which you would like method
documentation, you can supply these explicitly in place of the
argument expressions.  In the example above, if you want method
documentation for the first argument having class \code{"maybeNumber"}
and the second \code{"logical"}, call the \code{"?"} operator, this
time with a left-side argument \code{method}, and with a function call
on the right using the class names as arguments:

\code{method ? myFun("maybeNumber", "logical")}

Once again, a method will be selected, this time corresponding to the
specified classes, and method documentation will be requested.  This
version only works with generic functions.

The two forms each have advantages.  The version with actual arguments
doesn't require you to figure out (or guess at) the classes of the
arguments.
On the other hand, evaluating the arguments may take some time,
depending on the example.
The version with class names does require you to pick classes, but
it's otherwise unambiguous.  It has a subtler advantage, in that the
classes supplied may be virtual classes, in which case no actual
argument will have specifically this class.  The class
\code{"maybeNumber"}, for example, might be a class union (see the
example for \code{\LinkA{setClassUnion}{setClassUnion}}).

In either form, methods will be selected as they would be in actual
computation, including use of inheritance and group generic
functions.  See \code{\LinkA{selectMethod}{selectMethod}} for the details, since it is
the function used to find the appropriate method.

\end{Section}
%
\begin{Section}{Writing Documentation for Methods}
The on-line documentation for methods and classes uses some extensions
to the R documentation format to implement the requests for class and
method documentation described above.  See the document \emph{Writing
R Extensions} for the available markup commands (you should
have consulted this document already if you are at the stage of
documenting your software).

In addition to the specific markup commands to be described, you can
create an initial, overall file with a skeleton of documentation for
the methods defined for a particular generic function:

\code{promptMethods("myFun")}

will create a file, \file{myFun-methods.Rd} with a skeleton of
documentation for the methods defined for function \code{myFun}.
The output from \code{promptMethods} is suitable if you want to
describe all or most of the methods for the function in one file,
separate from the documentation of the generic function itself.
Once the file has been filled in and moved to the \file{man}
subdirectory of your source package, requests for methods
documentation will use that file, both for specific methods
documentation as described above, and for overall documentation
requested by

\code{methods ? myFun}

You are not required to use \code{promptMethods}, and if you do, you
may not want to use the entire file created:
\begin{itemize}

\item If you want to document the methods in the file containing the
documentation for the generic function itself, you can
cut-and-paste to move the \AsIs{\bsl{}alias} lines and the
\code{Methods} section from the file created by
\code{promptMethods} to the existing file.

\item On the other hand, if these are auxiliary methods, and you only
want to document the added or modified software, you should strip
out all but the relevant \AsIs{\bsl{}alias} lines for the methods of
interest, and remove all but the corresponding \AsIs{\bsl{}item}
entries in the \code{Methods} section. Note that in this case you
will usually remove the first  \AsIs{\bsl{}alias} line as well, since
that is the marker for general methods documentation on this
function (in the example, \samp{\bsl{}alias\{myfun-methods\}}).

\end{itemize}


If you simply want to direct documentation for one or more methods to
a particular R documentation file, insert the appropriate alias.
\end{Section}
\inputencoding{latin1}
\HeaderA{dotsMethods}{The Use of "..." in Method Signatures}{dotsMethods}
\keyword{programming}{dotsMethods}
\keyword{classes}{dotsMethods}
\keyword{methods}{dotsMethods}
%
\begin{Description}\relax
The ``\dots'' argument in \R{} functions is treated specially, in that it
matches zero, one or more actual arguments (and so, objects).  A
mechanism has been added to \R{} to allow ``\dots'' as the signature of a
generic function.  Methods defined for such functions will be
selected and called when \emph{all}  the arguments matching ``\dots''
are from the specified class or from some subclass of that class.
\end{Description}
%
\begin{Section}{Using "..." in a Signature}
Beginning with version 2.8.0 of \R{}, S4 methods can be dispatched
(selected and called) corresponding to the special argument ``\dots''.
Currently, ``\dots'' cannot be mixed with other formal arguments:
either the signature of the generic function is ``\dots'' only, or it
does not contain ``\dots''.  (This restriction may be lifted in a future
version.)

Given a suitable generic function, methods are specified in the
usual way by a call to \code{\LinkA{setMethod}{setMethod}}.  The method
definition must be written expecting all the arguments corresponding
to ``\dots'' to be from the class specified in the method's signature,
or from a class that extends that class (i.e., a subclass of that
class).

Typically the methods will pass ``\dots'' down to another function or
will create a list of the arguments and iterate over that.  See the
examples below.

When you have a computation that is suitable for more than one existing
class, a convenient approach may be to define a union of these
classes by a call to \code{\LinkA{setClassUnion}{setClassUnion}}. See the example
below.

\end{Section}
%
\begin{Section}{Method Selection and Dispatch for "..."}
See \LinkA{Methods}{Methods} for a general discussion.  The following assumes
you have read the ``Method Selection and Dispatch'' section of
that documentation.

A method selecting on ``\dots'' is specified by a single class in the
call to \code{\LinkA{setMethod}{setMethod}}.  If all the actual arguments
corresponding to ``\dots'' have this class, the corresponding method is
selected directly.

Otherwise, the class of each argument and that class' superclasses are
computed, beginning with the first ``\dots'' argument.  For the first
argument, eligible methods are those for any of the classes.   For
each succeeding argument that introduces a class not considered previously, the eligible methods are further
restricted to those matching the argument's class or
superclasses. If no further eligible classes exist, the iteration
breaks out and the default method, if any, is selected.

At the end of the iteration, one or more methods may be eligible.
If more than one, the selection looks for the method with the least
distance to the actual arguments.  For each argument, any inherited
method corresponds to a distance, available from the \code{contains}
slot of the class definition.  Since the same class can arise for
more than one argument, there may be several distances associated
with it.  Combining them is inevitably arbitrary:  the current
computation uses the minimum distance.  Thus, for example, if a
method matched one argument directly, one as  first generation
superclass and another as a second generation superclass, the
distances are 0, 1 and 2.  The current selection computation would
use distance 0 for this
method.  In particular, this selection criterion tends to use a method that
matches exactly one or more of the arguments' class.

As with ordinary method selection, there may be multiple methods
with the same distance.  A warning  message is issued and one of the
methods is chosen (the first encountered, which in this case is
rather arbitrary).

Notice that, while the computation examines all arguments, the
essential cost of dispatch goes up with the number of
\emph{distinct} classes among the arguments, likely to be much
smaller than the number of arguments when the latter is large.

\end{Section}
%
\begin{Section}{Implementation Details}
Methods dispatching on ``\dots'' were introduced in version 2.8.0 of
\R{}.  The initial implementation of the corresponding selection and
dispatch is in an R function, for flexibility while the new
mechanism is being studied.  In this implementation, a local version
of \code{setGeneric} is inserted in the generic function's
environment.  The local version selects a method according to the
criteria above and calls that method, from the environment of the
generic function.  This is slightly different from the action taken
by the C implementation when ``\dots'' is not involved.  Aside from the
extra computing time required, the method is evaluated in a true
function call, as opposed to the special context constructed by the
C version (which cannot be exactly replicated in R code.)  However,
situations in which different computational results would
be obtained have not been encountered so far, and seem very
unlikely.

Methods dispatching on arguments other than ``\dots'' are \emph{cached} by storing
the inherited method in the table of all methods, where it will be
found on the next selection with the same combination of classes
in the actual arguments (but not used for inheritance searches).
Methods based on ``\dots'' are also cached, but not found quite
as immediately.  As noted, the selected method depends only on the
set of classes that occur in the ``\dots'' arguments.  Each of
these classes can appear one or more times, so many combinations of
actual argument classes will give rise to the same effective
signature.  The selection computation first computes and sorts the
distinct classes encountered.  This gives a label that will be
cached in the table of all methods, avoiding any further search for
inherited classes after the first occurrence.  A call to
\code{\LinkA{showMethods}{showMethods}} will expose such inherited methods.

The intention is that the ``\dots'' features will be added to the
standard C code when enough experience with them has been obtained.
It is possible that at the same time, combinations of ``\dots'' with
other arguments in signatures may be supported.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
For the general discussion of methods, see  \LinkA{Methods}{Methods} and links
from there.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
cc <- function(...)c(...)

setGeneric("cc")

setMethod("cc", "character", function(...)paste(...))

setClassUnion("Number", c("numeric", "complex"))

setMethod("cc", "Number", function(...) sum(...))

setClass("cdate", contains = "character", representation(date = "Date"))

setClass("vdate", contains = "vector", representation(date = "Date"))

cd1 <- new("cdate", "abcdef", date = Sys.Date())

cd2 <- new("vdate", "abcdef", date = Sys.Date())

stopifnot(identical(cc(letters, character(), cd1), paste(letters, character(), cd1))) # the "character" method

stopifnot(identical(cc(letters, character(), cd2), c(letters, character(), cd2))) # the default, because "vdate" doesn't extend "character"

stopifnot(identical(cc(1:10, 1+1i), sum(1:10, 1+1i))) # the "Number" method

stopifnot(identical(cc(1:10, 1+1i, TRUE), c(1:10, 1+1i, TRUE))) # the default

stopifnot(identical(cc(), c())) # no arguments implies the default method

setGeneric("numMax", function(...)standardGeneric("numMax"))

setMethod("numMax", "numeric", function(...)max(...)) # won't work for complex data
setMethod("numMax", "Number", function(...) paste(...)) # should not be selected w/o complex args

stopifnot(identical(numMax(1:10, pi, 1+1i), paste(1:10, pi, 1+1i)))
stopifnot(identical(numMax(1:10, pi, 1), max(1:10, pi, 1)))

try(numMax(1:10, pi, TRUE)) # should be an error:  no default method

## A generic version of paste(), dispatching on the "..." argument:
setGeneric("paste", signature = "...")

setMethod("paste", "Number", function(..., sep, collapse) c(...))

stopifnot(identical(paste(1:10, pi, 1), c(1:10, pi, 1)))


\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{environment-class}{Class "environment"}{environment.Rdash.class}
\keyword{classes}{environment-class}
%
\begin{Description}\relax
 A formal class for R environments.
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects can be created by calls of the form \code{new("environment", ...)}.
The arguments in \dots, if any, should be named and will be assigned to
the newly created environment.
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[coerce] \code{signature(from = "ANY", to = "environment")}:
calls \code{\LinkA{as.environment}{as.environment}}. 
\item[initialize] \code{signature(object = "environment")}:
Implements the assignments in the new environment.  Note that the
\code{object} argument is ignored; a new environment is
\emph{always} created, since environments are not protected by copying. 

\end{description}

\end{Section}
%
\begin{SeeAlso}\relax
 \code{\LinkA{new.env}{new.env}} 
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{findClass}{Computations with Classes}{findClass}
\aliasA{getClasses}{findClass}{getClasses}
\aliasA{isClass}{findClass}{isClass}
\aliasA{removeClass}{findClass}{removeClass}
\aliasA{resetClass}{findClass}{resetClass}
\aliasA{sealClass}{findClass}{sealClass}
\keyword{programming}{findClass}
\keyword{classes}{findClass}
\keyword{methods}{findClass}
%
\begin{Description}\relax
Functions to find and manipulate class definitions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
removeClass(Class, where)

isClass(Class, formal=TRUE, where)

getClasses(where, inherits = missing(where))

findClass(Class, where, unique = "")

resetClass(Class, classDef, where)

sealClass(Class, where)

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}] character string name for the class.  The functions will
usually take a class definition instead of the string.  To restrict
the class to those defined in a particular package, set the
\code{\LinkA{packageSlot}{packageSlot}} of the character string.
\item[\code{where}]  The
environment in which to modify or remove the
definition.  Defaults to the top-level environment of the calling function
(the global environment for ordinary computations, but the
environment or name space of a package in the source for a package).

When searching for class definitions, \code{where} defines where to
do the search, and the default is to search from the top-level
environment or name space of the caller to this function.

\item[\code{unique}] if \code{findClass} expects a unique location for the
class, \code{unique} is a character string explaining the purpose
of the search (and is used in warning and error messages).  By
default, multiple locations are possible and the function always
returns a list.

\item[\code{inherits}] in a call to \code{getClasses}, should the value
returned include all parent environments of \code{where}, or that
environment only?  Defaults to \code{TRUE} if \code{where} is
omitted, and to \code{FALSE} otherwise.

\item[\code{formal}]  Should a formal definition be required? 
\item[\code{classDef}]  For \code{removeClass}, the optional class
definition (but usually it's better for \code{Class} to be the
class definition, and to omit \code{classDef}).

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
These are the functions that test and manipulate formal class
definitions.  Brief documentation is provided below.  See the
references for an introduction and for more details.

\begin{description}

\item[\code{removeClass}:] 
Remove the definition of this class, from the environment
\code{where} if this argument is supplied; if not,
\code{removeClass} will search for a definition, starting in the
top-level environment of the call to \code{removeClass}, and
remove the (first) definition found.

\item[\code{isClass}:] 
Is this the name of a formally defined class? (Argument
\code{formal} is for compatibility and is ignored.)

\item[\code{getClasses}:] 
The names of all the classes formally defined on \code{where}.  If
called with no argument, all the classes visible from the
calling function (if called from the top-level, all the classes
in any of the environments on the search list).  The
\code{inherits} argument can be used to search a particular
environment and all its parents, but usually the default setting
is what you want.

\item[\code{findClass}:] 
The list of environments or positions on the search list in
which a class definition of \code{Class} is found.  If
\code{where} is supplied, this is an environment (or name space)
from which the search takes place; otherwise the top-level
environment of the caller is used.  If \code{unique} is supplied
as a character string, \code{findClass} returns a single
environment or position.  By default, it always returns a list.
The calling function should select, say, the first element as a
position or environment for functions such as \code{\LinkA{get}{get}}.

If \code{unique} is supplied as a character string,
\code{findClass} will warn if there is more than one definition
visible (using the string to identify the purpose of the call),
and will generate an error if no definition can be found.

\item[\code{resetClass}:] 
Reset the internal definition of a class.  Causes the complete
definition of the class to be re-computed, from the
representation and superclasses specified in the original
call to \code{setClass}.

This function is called when aspects of the class definition are
changed.  You would need to call it explicitly if you changed the
definition of a class that this class extends (but doing that in
the  middle of a session is living dangerously, since it may
invalidate existing objects).

\item[\code{sealClass}:]  Seal the current definition of the specified
class, to prevent further changes.  It is possible to seal a class
in the call to \code{setClass}, but sometimes further changes have
to be made (e.g., by calls to \code{setIs}).  If so, call
\code{sealClass} after all the relevant changes have been made.


\end{description}

\end{Details}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{setClassUnion}{setClassUnion}},
\code{\LinkA{Methods}{Methods}},
\code{\LinkA{makeClassRepresentation}{makeClassRepresentation}}
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{findMethods}{Descriptions of the Methods Defined for a Generic Function}{findMethods}
\aliasA{findMethodSignatures}{findMethods}{findMethodSignatures}
\aliasA{getMethods}{findMethods}{getMethods}
\aliasA{hasMethods}{findMethods}{hasMethods}
\keyword{programming}{findMethods}
\keyword{classes}{findMethods}
\keyword{methods}{findMethods}
%
\begin{Description}\relax
These functions convert the methods defined in a table for a generic
function (as used for selection of methods) into a list, for study or
display, or provide other information summarizing the methods.

The function \code{findMethods} returns a list of the method
definitions currently existing for generic function \code{f}, limited
to the methods defined in environment \code{where} if that argument is
supplied and possibly limited to those including one or more of the
specified \code{classes} in the method signature.

The function \code{findMethodSignatures} returns a character matrix
whose rows are the class names from the signature of the corresponding
methods; it operates either from a list returned by
\code{findMethods}, or by computing such a list itself, given the same
arguments as \code{findMethods} .

The function \code{hasMethods} returns \code{TRUE} or \code{FALSE}
according to whether there is a non-empty table of methods for
function \code{f} in the environment or search position \code{where}
(or anywhere on the search list if \code{where} is missing).

The function \code{getMethods} is an older alternative to
\code{findMethods} , returning information in the form of an object of
class \code{MethodsList}, previously used for method dispatch.  It is
not recommended, since the object returned is usually less convenient
than the value of \code{findMethods}.  
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findMethods(f, where, classes = character(), inherited = FALSE)
findMethodSignatures(..., target = TRUE, methods = )

hasMethods(f, where, package)

getMethods(f, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}] A generic function or the character-string name of one.
\item[\code{where}] Optionally, an environment or position on the search list
to look for methods metadata.

If \code{where} is missing,  \code{findMethods} uses the current
table of methods in the generic function itself, and
\code{hasMethods} looks for metadata anywhere in the search list.

\item[\code{classes}] If supplied, only methods whose signatures contain at
least one of the supplied classes will be included in the value
returned.
\item[\code{inherited}] Logical flag; if \code{TRUE}, the table of all
methods, inherited or defined directly, will be used; otherwise,
only the methods explicitly defined.  Option \code{TRUE} is
meaningful only if \code{where} is missing.

\item[\code{...}] In the call to \code{findMethodSignatures}, any arguments
that might be given to \code{findMethods}.
\item[\code{target}] Optional flag to \code{findMethodSignatures}; if
\code{TRUE}, the signatures used are the target signatures (the
classes for which the method will be selected); if \code{FALSE},
they will be the signatures are defined.  The difference is only
meaningful if \code{inherited} is \code{TRUE}.
\item[\code{methods}] In the call to \code{findMethodSignatures}, an optional
list of methods, presumably returned by a previous call to
\code{findMethods}.  If missing, that function will be call with the
\dots arguments.

\item[\code{package}] In a call to \code{hasMethods}, the package name for
the generic function (e.g., \code{"base"} for primitives).  If
missing this will be inferred either from the \code{"package"}
attribute of the function name, if any, or from the package slot of
the generic function.  See `Details'.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax

The functions obtain a table of the defined methods, either from the
generic function or from the stored metadata object in the environment
specified by \code{where}.  The information in the table is converted
as described above to produce the returned value.

Note that the list returned may contain the primitive function itself,
when the generic corresponds to a primitive.  (Basically, because
primitive functions are abnormal R objects, which cannot currently be
extended as method definitions.)  Computations that use the returned
list to derive other information need to take account of this
possibility.  See the implementation of \code{findMethodSignatures}
for an example.

Note that \code{hasMethods}, but not the other functions, can be used
even if no generic function of this name is currently found.  In this
case \code{package} must either be supplied as an argument or included
as an attribute of \code{f}, since the package name is part of the
identification of the methods tables.

These functions should be used in searching for or summarizing
methods, rather than using information about how the metadata for
methods is stored.
\end{Details}
%
\begin{SeeAlso}\relax
 \code{\LinkA{showMethods}{showMethods}}, \code{\LinkA{MethodsList-class}{MethodsList.Rdash.class}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
mm <-  findMethods("Ops")
findMethodSignatures(methods = mm)
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{fixPre1.8}{Fix Objects Saved from R Versions Previous to 1.8}{fixPre1.8}
\keyword{classes}{fixPre1.8}
\keyword{programming}{fixPre1.8}
%
\begin{Description}\relax
Beginning with R version 1.8.0, the class of an object contains the
identification of the package in which the class is defined.  The
function \code{fixPre1.8} fixes and re-assigns objects missing that information
(typically because they were loaded from a file saved with a previous
version of R.)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fixPre1.8(names, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{names}]  Character vector of the names of all the objects to be
fixed and re-assigned.
\item[\code{where}] The environment from which to look for the objects, and
for class definitions.  Defaults to the top environment of the
call to \code{fixPre1.8}, the global environment if the function
is used interactively.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The named object will be saved where it was found.  Its class
attribute will be changed to the full form required by R 1.8;
otherwise, the contents of the object should be unchanged.

Objects will be fixed and re-assigned only if all the following
conditions hold:
\begin{enumerate}

\item The named object exists.
\item It is from a defined class (not a basic datatype which
has no actual class attribute).
\item The object appears to be from an earlier version of R.
\item The class is currently defined.
\item The object is consistent with the current class definition.

\end{enumerate}

If any condition except the second fails, a warning message is
generated.

Note that \code{fixPre1.8} currently fixes \emph{only} the change in
class attributes.  In particular, it will not fix binary versions of
packages installed with earlier versions of R if these use
incompatible features.  Such packages must be re-installed from
source, which is the wise approach always when major version changes
occur in R.

\end{Details}
%
\begin{Value}
The names of all the objects that were in fact re-assigned.
\end{Value}
\inputencoding{latin1}
\HeaderA{genericFunction-class}{Generic Function Objects}{genericFunction.Rdash.class}
\aliasA{groupGenericFunction-class}{genericFunction-class}{groupGenericFunction.Rdash.class}
\keyword{classes}{genericFunction-class}
%
\begin{Description}\relax
Generic functions (objects from or extending class
\code{genericFunction}) are extended function objects,
containing information used in creating and dispatching methods for
this function.  They also identify the package associated with the
function and its methods.
\end{Description}
%
\begin{Section}{Objects from the Class}
Generic functions are created and assigned by
\code{\LinkA{setGeneric}{setGeneric}} or \code{\LinkA{setGroupGeneric}{setGroupGeneric}} and, indirectly, by
\code{\LinkA{setMethod}{setMethod}}.

As you might expect \code{\LinkA{setGeneric}{setGeneric}} and
\code{\LinkA{setGroupGeneric}{setGroupGeneric}} create objects of class
\code{"genericFunction"} and \code{"groupGenericFunction"} respectively.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] Object of class \code{"function"}, the
function definition of the generic, usually created
automatically as a call to \code{\LinkA{standardGeneric}{standardGeneric}}. 
\item[\code{generic}:] Object of class \code{"character"}, the
name of the generic function. 
\item[\code{package}:] Object of class \code{"character"}, the
name of the package to which the function definition belongs
(and \emph{not} necessarily where the generic function is
stored). If the package is not specified explicitly in the
call to \code{setGeneric}, it is usually the package on which
the corresponding non-generic function exists. 
\item[\code{group}:] Object of class \code{"list"}, the group or
groups to which this generic function belongs.  Empty by default. 
\item[\code{valueClass}:] Object of class \code{"character"}; if
not an empty character vector, identifies one or more classes.  It is
asserted that all methods for this function return objects
from these class (or from classes that extend them). 
\item[\code{signature}:] Object of class \code{"character"}, the
vector of formal argument names that can appear in the
signature of methods for this generic function.  By default,
it is all the formal arguments, except for \dots.  Order
matters for efficiency:  the most commonly used arguments in
specifying methods should come first. 
\item[\code{default}:] Object of class \code{"OptionalMethods"},
the default method for this function.  Generated
automatically and used to initialize method dispatch. 
\item[\code{skeleton}:] Object of class \code{"call"}, a slot used
internally in method dispatch.  Don't expect to use it
directly.

\end{description}

\end{Section}
%
\begin{Section}{Extends}
Class \code{"function"}, from data part.\\{}
Class \code{"OptionalMethods"}, by class \code{"function"}.\\{}
Class \code{"PossibleMethod"}, by class \code{"function"}.
\end{Section}
%
\begin{Section}{Methods}
Generic function objects are used in the creation and dispatch of
formal methods; information from the object is used to create methods
list objects and to merge or update the existing methods for this
generic.
\end{Section}
\inputencoding{latin1}
\HeaderA{GenericFunctions}{Tools for Managing Generic Functions}{GenericFunctions}
\aliasA{dumpMethod}{GenericFunctions}{dumpMethod}
\aliasA{dumpMethods}{GenericFunctions}{dumpMethods}
\aliasA{findFunction}{GenericFunctions}{findFunction}
\aliasA{getGenerics}{GenericFunctions}{getGenerics}
\aliasA{isGeneric}{GenericFunctions}{isGeneric}
\aliasA{isGroup}{GenericFunctions}{isGroup}
\aliasA{removeGeneric}{GenericFunctions}{removeGeneric}
\aliasA{removeMethods}{GenericFunctions}{removeMethods}
\aliasA{setReplaceMethod}{GenericFunctions}{setReplaceMethod}
\aliasA{signature}{GenericFunctions}{signature}
\keyword{programming}{GenericFunctions}
\keyword{classes}{GenericFunctions}
\keyword{methods}{GenericFunctions}
%
\begin{Description}\relax
The functions documented here manage collections of methods associated
with a generic function, as well as providing information about the
generic functions themselves.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
isGeneric(f, where, fdef, getName = FALSE)
isGroup(f, where, fdef)
removeGeneric(f, where)

dumpMethod(f, signature, file, where, def)
findFunction(f, generic = TRUE, where = topenv(parent.frame()))
dumpMethods(f, file, signature, methods, where)
signature(...)

removeMethods(f, where = topenv(parent.frame()), all = missing(where))
setReplaceMethod(f, ..., where = topenv(parent.frame()))

getGenerics(where, searchForm = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}]  The character string naming the function. 
\item[\code{where}]  The environment, name space, or search-list position
from which to search for objects.  By default, start at the
top-level environment of the calling function, typically the global
environment (i.e., use the search list), or the name space of a
package from which the call came.  It is important to supply this
argument when calling any of these functions indirectly.  With
package name spaces, the default is likely to be wrong in such calls.

\item[\code{signature}]  The class signature of the relevant method.  A
signature is a named or unnamed vector of character strings.  If
named, the names must be formal argument names for the generic
function.  If \code{signature} is unnamed, the default is to use
the first \code{length(signature)} formal arguments of the
function. 

\item[\code{file}]  The file or connection on which to dump method definitions. 

\item[\code{def}]  The function object defining the method; if omitted, the
current method definition corresponding to the signature. 

\item[\code{...}] Named or unnamed arguments to form a signature.

\item[\code{generic}] In testing or finding functions, should generic
functions be included.  Supply as \code{FALSE} to get only
non-generic functions.

\item[\code{fdef}] Optional, the generic function definition.

Usually omitted in calls to \code{isGeneric}

\item[\code{getName}] If \code{TRUE}, \code{isGeneric} returns the name of
the generic.  By default, it returns \code{TRUE}. 
\item[\code{methods}] 
The methods object containing the methods to be dumped.  By default,
the methods defined for this generic (optionally on the specified
\code{where} location).

\item[\code{all}] in \code{removeMethods}, logical indicating if all
(default) or only the first method found should be removed.
\item[\code{searchForm}] In \code{getGenerics}, if \code{TRUE}, the
\code{package} slot of the returned result is in the form used
by \code{search()}, otherwise as the simple package name (e.g,
\code{"package:base"} vs \code{"base"}).

\end{ldescription}
\end{Arguments}
%
\begin{Section}{Summary of Functions}
\begin{description}

\item[\code{isGeneric}:] 
Is there a function named \code{f}, and if so, is it a generic?

The \code{getName} argument allows a function to find the name
from a function definition.  If it is \code{TRUE} then the name of
the generic is returned, or \code{FALSE} if this is not a generic
function definition.

The behavior of \code{isGeneric} and \code{\LinkA{getGeneric}{getGeneric}} for
primitive functions is slightly different.  These functions don't
exist as formal function objects (for efficiency and historical
reasons), regardless of whether methods have been defined for
them.  A call to \code{isGeneric} tells you whether methods have
been defined for this primitive function, anywhere in the current
search list, or in the specified position \code{where}.  In
contrast, a call to \code{\LinkA{getGeneric}{getGeneric}} will return what the
generic for that function would be, even if no methods have been
currently defined for it.


\item[\code{removeGeneric}, \code{removeMethods}:] 
Remove all the methods for the generic function of this
name.  In addition, \code{removeGeneric} removes the function
itself; \code{removeMethods} restores the non-generic function
which was the default method.   If there was no default method,
\code{removeMethods} leaves a generic function with no methods.

\item[\code{standardGeneric}:] 
Dispatches a method from the current function call for the generic
function \code{f}.  It is an error to call
\code{standardGeneric} anywhere except in the body of the
corresponding generic function.

Note that \code{\LinkA{standardGeneric}{standardGeneric}} is a primitive function in
the \pkg{base} package
for efficiency 
reasons, but rather documented here where it belongs naturally.

\item[\code{dumpMethod}:] 
Dump the method for this generic function and signature.

\item[\code{findFunction}:] 
return a list of either the positions on the search list, or the
current top-level environment, on which a function object
for \code{name} exists.  The returned value is \emph{always} a
list, use the first element to access the first visible version
of the function.  See the example.

\emph{NOTE:} Use this rather than \code{\LinkA{find}{find}} with
\code{mode="function"}, which is not as meaningful, and has a few
subtle bugs from its use of regular expressions.  Also,
\code{findFunction} works correctly in the code for a package
when attaching the package via a call to \code{\LinkA{library}{library}}.

\item[\code{dumpMethods}:] 
Dump all the methods for this generic.

\item[\code{signature}:] 
Returns a named list of classes to be matched to arguments of a
generic function.

\item[\code{getGenerics}:] returns the names of the generic
functions that have methods defined on \code{where}; this
argument can be an environment or an index into the search
list.  By default, the whole search list is used.

The methods definitions are stored with
package qualifiers; for example, methods for function
\code{"initialize"} might refer to two different functions
of that name, on different packages.  The package names
corresponding to the method list object are contained in the
slot \code{package} of the returned object.  The form of
the returned name can be plain (e.g., \code{"base"}), or in
the form used in the search list (\code{"package:base"})
according to the value of \code{searchForm}


\end{description}

\end{Section}
%
\begin{Section}{Details}
\begin{description}

\item[\code{setGeneric}:] 
If there is already a non-generic function of this name, it will
be used to define the generic unless \code{def} is supplied, and
the current function will become the default method for the
generic.

If \code{def} is supplied, this defines the generic function, and
no default method will exist (often a good feature, if the
function should only be available for a meaningful subset of all
objects).

Arguments \code{group} and \code{valueClass} are retained for
consistency with S-Plus, but are currently not used.

\item[\code{isGeneric}:] 
If the \code{fdef} argument is supplied, take this as the
definition of the generic, and test whether it is really a
generic, with \code{f} as the name of the generic.  (This argument
is not available in S-Plus.)

\item[\code{removeGeneric}:] 
If \code{where} supplied, just remove the version on this element
of the search list; otherwise, removes the first version
encountered.

\item[\code{standardGeneric}:] 
Generic functions should usually have a call to
\code{standardGeneric} as their entire body.  They can, however,
do any other computations as well.

The usual \code{setGeneric} (directly or through calling
\code{setMethod}) creates a function with a call to
\code{standardGeneric}.

\item[\code{dumpMethod}:] 
The resulting source file will recreate the method.

\item[\code{findFunction}:] 
If \code{generic} is \code{FALSE}, ignore generic functions.

\item[\code{dumpMethods}:] 
If \code{signature} is supplied only the methods matching this
initial signature are dumped.  (This feature is not found in
S-Plus:  don't use it if you want compatibility.)

\item[\code{signature}:] 
The advantage of using \code{signature} is to provide a check on
which arguments you meant, as well as clearer documentation in
your method specification.  In addition, \code{signature} checks
that each of the elements is a single character string.

\item[\code{removeMethods}:] 
Returns \code{TRUE} if \code{f} was a generic function,
\code{FALSE} (silently) otherwise.

If there is a default method, the function will be re-assigned as
a simple function with this definition.
Otherwise, the generic function remains but with no methods (so
any call to it will generate an error).  In either case, a
following call to \code{setMethod} will consistently
re-establish the same generic function as before.


\end{description}

\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{getMethod}{getMethod}} (also for \code{selectMethod}),
\code{\LinkA{setGeneric}{setGeneric}},
\code{\LinkA{setClass}{setClass}},
\code{\LinkA{showMethods}{showMethods}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
require(stats) # for lm

## get the function "myFun" -- throw an error if 0 or > 1 versions visible:
findFuncStrict <- function(fName) {
  allF <- findFunction(fName)
  if(length(allF) == 0)
    stop("No versions of ",fName," visible")
  else if(length(allF) > 1)
    stop(fName," is ambiguous: ", length(allF), " versions")
  else
    get(fName, allF[[1]])
}

try(findFuncStrict("myFun"))# Error: no version
lm <- function(x) x+1
try(findFuncStrict("lm"))#    Error: 2 versions
findFuncStrict("findFuncStrict")# just 1 version
rm(lm)



## method dumping ------------------------------------

setClass("A", representation(a="numeric"))
setMethod("plot", "A", function(x,y,...){ cat("A meth\n") })
dumpMethod("plot","A", file="")
## Not run: 
setMethod("plot", "A",
function (x, y, ...)
{
    cat("AAAAA\n")
}
)

## End(Not run)
tmp <- tempfile()
dumpMethod("plot","A", file=tmp)
## now remove, and see if we can parse the dump
stopifnot(removeMethod("plot", "A"))
source(tmp)
stopifnot(is(getMethod("plot", "A"), "MethodDefinition"))

## same with dumpMethods() :
setClass("B", contains="A")
setMethod("plot", "B", function(x,y,...){ cat("B ...\n") })
dumpMethods("plot", file=tmp)
stopifnot(removeMethod("plot", "A"),
          removeMethod("plot", "B"))
source(tmp)
stopifnot(is(getMethod("plot", "A"), "MethodDefinition"),
          is(getMethod("plot", "B"), "MethodDefinition"))
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{getClass}{Get Class Definition}{getClass}
\aliasA{getClassDef}{getClass}{getClassDef}
\keyword{programming}{getClass}
\keyword{classes}{getClass}
%
\begin{Description}\relax
Get the definition of a class.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getClass(Class, .Force = FALSE, where)
getClassDef(Class, where, package, inherits = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}]  the character-string name of the class, often with a
\code{"package"} attribute as noted below under \code{package}.
\item[\code{.Force}]  if \code{TRUE}, return \code{NULL} if the class is
undefined; otherwise, an undefined class results in an error.
\item[\code{where}]  environment from which to begin the search for the definition; by default,
start at the top-level (global) environment and proceed through
the search list.
\item[\code{package}]  the name of the package asserted to hold the
definition.  If it is a non-empty string it is used instead of
\code{where}, as the first place to look for the class.
Note that the package must be loaded but need not be attached.  By
default, the package attribute of the \code{Class} argument is
used, if any.  There will usually be a package attribute if
\code{Class} comes from \code{class(x)} for some object.

\item[\code{inherits}]  Should the class definition be retrieved from any
enclosing environment and also from the cache?  If \code{FALSE}
only a definition in the environment \code{where} will be returned.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Class definitions are stored in metadata objects in a package
namespace or other environment where they are defined.  When
packages are loaded, the class definitions in the package are cached in an internal
table.  Therefore, most calls to \code{getClassDef} will find the
class in the cache or fail to find it at all, unless \code{inherits}
is \code{FALSE}, in which case only the environment(s) defined by
\code{package} or \code{where} are searched.

The class cache allows for multiple definitions of the
same class name in separate environments, with of course the
limitation that the package attribute or package name must be
provided in the call to 

\end{Details}
%
\begin{Value}
The object defining the class. If the class definition is not found,
\code{getClassDef} returns \code{NULL}, while \code{getClass}, which
calls \code{getClassDef}, either generates an error or, if
\code{.Force} is \code{TRUE}, returns a simple definition for the
class.  The latter case is used internally, but is not typically
sensible in user code.

The non-null returned value is an object of class
\code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}.  For all reasonable
purposes, use this object only to extract information, rather than trying
to modify it: Use functions such as \code{\LinkA{setClass}{setClass}} and
\code{\LinkA{setIs}{setIs}} to create or modify class definitions.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\LinkA{Classes}{Classes},
\code{\LinkA{setClass}{setClass}},
\code{\LinkA{isClass}{isClass}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
getClass("numeric") ## a built in class

cld <- getClass("thisIsAnUndefinedClass", .Force = TRUE)
cld ## a NULL prototype
## If you are really curious:
utils::str(cld)
## Whereas these generate errors:
try(getClass("thisIsAnUndefinedClass"))
try(getClassDef("thisIsAnUndefinedClass"))
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{getMethod}{Get or Test for the Definition of a Method}{getMethod}
\aliasA{existsMethod}{getMethod}{existsMethod}
\aliasA{findMethod}{getMethod}{findMethod}
\aliasA{hasMethod}{getMethod}{hasMethod}
\aliasA{selectMethod}{getMethod}{selectMethod}
\keyword{programming}{getMethod}
\keyword{classes}{getMethod}
\keyword{methods}{getMethod}
%
\begin{Description}\relax
Functions to look for a method corresponding to a given generic function and signature.
The functions \code{getMethod} and \code{selectMethod} return the method; the functions \code{existsMethod}
and \code{hasMethod} test for its existence.  In both
cases the first function only gets direct definitions and the second
uses inheritance.  In all cases, the search is in the generic function itself or in the package/environment specified by argument \code{where}.

The function \code{findMethod} returns the package(s) in the search
list (or in the packages specified by the \code{where} argument) that
contain a method for this function and signature.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getMethod(f, signature=character(), where, optional = FALSE,
          mlist, fdef)

existsMethod(f, signature = character(), where)

findMethod(f, signature, where)

selectMethod(f, signature, optional = FALSE, useInherited =,
             mlist = , fdef = , verbose = )

hasMethod(f, signature=character(), where)

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}] A  generic function or the character-string name of one.
\item[\code{signature}] the signature of classes to match to the arguments
of \code{f}.  See the details below.


\item[\code{where}] The position or environment in which to look for the
method(s):  by default, the table of methods defined in the generic function itself is used.

\item[\code{optional}]  If the selection in  \code{selectMethod} does find a valid method
an error is generated, unless this argument is \code{TRUE}.  In that
case, the value returned is  \code{NULL} if no
method matches.
\item[\code{mlist, fdef, useInherited, verbose}] Optional arguments  to  \code{getMethod} and \code{selectMethod}.  Avoid these: some will work and others will not, and none of them is required for normal use of the functions.


\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The \code{signature} argument specifies classes, corresponding to formal arguments of the generic function; to be precise, to the \code{signature} slot of the generic function object.
The argument may be a vector of strings identifying
classes, and may be named or not.  Names, if supplied, match the
names of those formal arguments included in the signature of the
generic.  That signature is normally all the arguments except
\dots.  However, generic functions can be specified with only a
subset of the arguments permitted, or with the signature taking
the arguments in a different order.

It's a good idea to name the arguments in the signature to avoid
confusion, if you're dealing with a generic that does something
special with its signature.   In any case, the elements of the
signature are matched to the formal signature by the same rules
used in matching arguments in function calls (see
\code{\LinkA{match.call}{match.call}}).

The strings in the signature may be class names, \code{"missing"}
or \code{"ANY"}.  See \LinkA{Methods}{Methods} for the meaning of these in
method selection.  Arguments not supplied in the signature
implicitly correspond to class \code{"ANY"}; in particular, giving
an empty signature means to look for the default method.

A call to \code{getMethod} returns the method for a particular
function and signature.  As with other \code{get} functions,
argument \code{where} controls where the function looks (by default
anywhere in the search list) and argument \code{optional} controls
whether the function returns \code{NULL} or generates an error if
the method is not found.  The search for the method makes no use of
inheritance.

The function \code{selectMethod} also looks for a method given the
function and signature, but makes full use of the method dispatch
mechanism; i.e., inherited methods and group generics are taken into
account just as they would be in dispatching a method for the
corresponding signature, with the one exception that conditional
inheritance is not used.  Like \code{getMethod}, \code{selectMethod}
returns \code{NULL} or generates an error if
the method is not found, depending on the argument \code{optional}.

The functions \code{existsMethod} and \code{hasMethod} return
\code{TRUE} or \code{FALSE} according to whether a method is found,
the first corresponding to \code{getMethod} (no inheritance) and the
second to \code{selectMethod}.

\end{Details}
%
\begin{Value}
The call to \code{selectMethod} or \code{getMethod} returns  the selected method, if
one is found.
(This class extends \code{function}, so you can use the result
directly as a function if that is what you want.)
Otherwise an error is thrown if \code{optional} is \code{FALSE}  and  \code{NULL} is returned if
\code{optional} is \code{TRUE}.

The returned method object is a
\code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}} object, \emph{except} that the default method for a primitive function is required to be the primitive itself.
Note therefore that the only reliable test that the search failed is \code{is.null()}.

\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{Methods}{Methods}} for the details of method
selection; \code{\LinkA{GenericFunctions}{GenericFunctions}} for other functions
manipulating methods and generic function objects;
\code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}} for the class that represents
method definitions.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
setGeneric("testFun", function(x)standardGeneric("testFun"))
setMethod("testFun", "numeric", function(x)x+1)
hasMethod("testFun", "numeric")
## Not run: [1] TRUE
hasMethod("testFun", "integer") #inherited
## Not run: [1] TRUE
existsMethod("testFun", "integer")
## Not run: [1] FALSE
hasMethod("testFun") # default method
## Not run: [1] FALSE
hasMethod("testFun", "ANY")
## Not run: [1] FALSE

\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{getPackageName}{The Name associated with a Given Package}{getPackageName}
\aliasA{packageSlot}{getPackageName}{packageSlot}
\aliasA{packageSlot<\Rdash}{getPackageName}{packageSlot<.Rdash.}
\aliasA{setPackageName}{getPackageName}{setPackageName}
\keyword{programming}{getPackageName}
%
\begin{Description}\relax
The functions below produce the package associated with a particular
environment or position on the search list, or of the package
containing a particular function.  They are primarily used to support
computations that need to differentiate objects on multiple packages.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getPackageName(where, create = TRUE)
setPackageName(pkg, env)

packageSlot(object)
packageSlot(object) <- value
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{where}] the environment or position on the search list
associated with the desired package.
\item[\code{object}] object providing a character string name, plus the
package in which this object is to be found.
\item[\code{value}] the name of the package.
\item[\code{create}] flag, should a package name be created if none can be
inferred?  If \code{TRUE} and no non-empty package name is found,
the current date and time are used as a package name, and a
warning is issued. The created name is stored in the environment
if that environment is not locked.
\item[\code{pkg, env}] make the string in \code{pkg} the internal
package name for all computations that set class and method
definitions in environment \code{env}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Package names are normally installed during loading of the package,
by the \LinkA{INSTALL}{INSTALL} script or by the \code{\LinkA{library}{library}}
function.  (Currently, the name is stored as the object
\code{.packageName} but don't trust this for the future.)
\end{Details}
%
\begin{Value}
\code{packageName} returns the character-string name of the package
(without the extraneous \code{"package:"} found in the search list).

\code{packageSlot} returns or sets the package name slot (currently
an attribute, not a formal slot, but this may change someday).

\code{setPackageName} can be used to establish a package name in an
environment that would otherwise not have one.  This
allows you to create classes and/or methods in an arbitrary
environment, but it is usually preferable to create packages by the
standard \R{} programming tools (\code{\LinkA{package.skeleton}{package.skeleton}}, etc.)
\end{Value}
%
\begin{SeeAlso}\relax
 \code{\LinkA{search}{search}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## all the following usually return "base"
getPackageName(length(search()))
getPackageName(baseenv())
getPackageName(asNamespace("base"))
getPackageName("package:base")

\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{hasArg}{Look for an Argument in the Call}{hasArg}
\keyword{programming}{hasArg}
%
\begin{Description}\relax
Returns \code{TRUE} if \code{name} corresponds to an argument in the
call, either a formal argument to the function, or a component of
\code{...}, and \code{FALSE} otherwise.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
hasArg(name)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}] The unquoted name of a potential argument.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The expression \code{hasArg(x)}, for example, is similar to
\code{!missing(x)}, with two exceptions.  First,  \code{hasArg} will look for
an argument named \code{x} in the call if \code{x} is not a formal
argument to the calling function, but \code{...} is.  Second,
\code{hasArg} never generates an error if given a name as an argument,
whereas \code{missing(x)} generates an error if \code{x} is not a
formal argument.
\end{Details}
%
\begin{Value}
Always \code{TRUE} or \code{FALSE} as described above.
\end{Value}
%
\begin{SeeAlso}\relax
 \code{\LinkA{missing}{missing}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
ftest <- function(x1, ...) c(hasArg(x1), hasArg(y2))

ftest(1) ## c(TRUE, FALSE)
ftest(1, 2)  ## c(TRUE, FALSE)
ftest(y2=2)   ## c(FALSE, TRUE)
ftest(y=2)    ## c(FALSE, FALSE) (no partial matching)
ftest(y2 = 2, x=1)  ## c(TRUE, TRUE) partial match x1


\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{implicitGeneric}{Manage Implicit Versions of Generic Functions}{implicitGeneric}
\aliasA{implicit generic}{implicitGeneric}{implicit generic}
\aliasA{prohibitGeneric}{implicitGeneric}{prohibitGeneric}
\aliasA{registerImplicitGenerics}{implicitGeneric}{registerImplicitGenerics}
\aliasA{setGenericImplicit}{implicitGeneric}{setGenericImplicit}
\keyword{programming}{implicitGeneric}
\keyword{methods}{implicitGeneric}
%
\begin{Description}\relax
Create or access implicit generic functions, used to enforce
consistent generic versions of functions that are not currently
generic.  Function \code{implicitGeneric()} returns the implicit
generic version, \code{setGenericImplicit()} turns a generic implicit,
\code{prohibitGeneric()} prevents your function from being made
generic, and \code{registerImplicitGenerics()} saves a set of implicit
generic definitions in the cached table of the current session.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
implicitGeneric(name, where, generic)
setGenericImplicit(name, where, restore = TRUE)
prohibitGeneric(name, where)
registerImplicitGenerics(what, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}]  Character string name of the function.
\item[\code{where}]  Package or environment in which to register the implicit
generics.  When using the functions from the top level of your own
package source, this argument can usually be omitted (and should
be).
\item[\code{generic}]  Optionally, the generic function definition to be
cached, but usually omitted.   See Details section.
\item[\code{restore}] Should the non-generic version of the function be
restored after the current.
\item[\code{what}] For \code{registerImplicitGenerics()}, Optional table of
the implicit generics to register, but nearly always omitted.   See
Details section.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Multiple packages may define methods for the same function, using the
version of a function stored in one package.  All these methods should
be marshaled and dispatched consistently when a user calls the
function.  For consistency, the generic version of the function must
have a unique definition (the same arguments allowed in methods
signatures, the same values for optional slots such as the value
class, and the same standard or non-standard definition of the
function itself).

If the original function is already an S4 generic, there is no
problem.  The implicit generic mechanism enforces consistency when the
version in the package owning the function is \emph{not} generic.  If
a call to \code{\LinkA{setGeneric}{setGeneric}()} attempts to turn a function in
another package into a generic, the mechanism compares the proposed
new generic function to the implicit generic version of that
function. If the two agree, all is well. If not, and if the function
belongs to another package, then the new generic will not be
associated with that package.  Instead, a warning is issued and a
separate generic function is created, with its package slot set to the
current package, not the one that owns the non-generic version of the
function. The effect is that the new package can still define methods
for this function, but it will not share the methods in other
packages, since it is forcing a different definition of the generic
function.

The right way to proceed in nearly all cases is to call
\code{\LinkA{setGeneric}{setGeneric}("foo")}, giving \emph{only} the name of the
function; this will automatically use the implicit generic version.
If you don't like that version, the best solution is to convince the
owner of the other package to agree with you and to insert code to
define the non-default properties of the function (even if the owner
does not want \code{foo()} to be a generic by default).

For any function, the implicit generic form is a standard generic in
which all formal arguments, except for \code{...}, are allowed in
the signature of methods. If that is the suitable generic for a
function, no action is needed. If not, the best mechanism is to set up
the generic in the code of the package owning the function, and to
then call \code{setGenericImplicit()} to record the implicit generic
and restore the non-generic version.  See the example.

Note that the package can define methods for the implicit generic as
well; when the implicit generic is made a real generic, those methods
will be included.

Other than predefining  methods, the usual reason for having a
non-default implicit generic is to provide a non-default signature,
and the usual reason for \emph{that} is to allow lazy evaluation of
some arguments.  See the example.  All arguments in the signature of a
generic function must be evaluated at the time the function needs to
select a method.  (But those arguments can be missing, with or without
a default expression being defined; you can always examine
\code{missing(x)} even for arguments in the signature.)

If you want to completely prohibit anyone from turning your function
into a generic, call \code{prohibitGeneric()}.
\end{Details}
%
\begin{Value}
Function \code{implicitGeneric()} returns the implicit generic
definition (and caches that definition the first time if it has to
construct it).

The other functions exist for their side effect and return nothing
useful.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{setGeneric}{setGeneric}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

### How we would make the function \link{with}() into a generic:

## Since the second argument, 'expr' is used literally, we want
## with() to only have "data" in the signature.

## Note that 'methods'-internal code now has already extended  with()
## to do the equivalent of the following
## Not run: 
setGeneric("with", signature = "data")
## Now we could predefine methods for "with" if we wanted to.

## When ready, we store the generic as implicit, and restore the original
setGenericImplicit("with")

## (This example would only work if we "owned" function with(),
##  but it is in base.)
## End(Not run)

implicitGeneric("with")
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{inheritedSlotNames}{Names of Slots Inherited From a Super Class}{inheritedSlotNames}
\keyword{classes}{inheritedSlotNames}
\keyword{methods}{inheritedSlotNames}
%
\begin{Description}\relax
For a class (or class definition, see \code{\LinkA{getClass}{getClass}} and
the description of class \code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}),
give the names which are inherited from ``above'', i.e., super
classes, rather than by this class' definition itself.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
inheritedSlotNames(Class, where = topenv(parent.frame()))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}] character string or
\code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}, i.e., resulting from
\code{\LinkA{getClass}{getClass}}.
\item[\code{where}] environment, to be passed further to
\code{\LinkA{isClass}{isClass}} and \code{\LinkA{getClass}{getClass}}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
character vector of slot names, or \code{\LinkA{NULL}{NULL}}.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{slotNames}{slotNames}}, \code{\LinkA{slot}{slot}}, \code{\LinkA{setClass}{setClass}}, etc.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
.srch <- search()
library(stats4)
inheritedSlotNames("mle")


## Not run: 
if(require("Matrix")) {
  print( inheritedSlotNames("Matrix") ) # NULL
  ## whereas
  print( inheritedSlotNames("sparseMatrix") ) # --> Dim & Dimnames
  ##  i.e. inherited from "Matrix" class

  print( cl <- getClass("dgCMatrix") ) # six slots, etc

  print( inheritedSlotNames(cl) ) # *all* six slots are inherited
}


## detach package we've attached above:
for(n in rev(which(is.na(match(search(), .srch)))))
    detach(pos = n)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{initialize-methods}{Methods to Initialize New Objects from a Class}{initialize.Rdash.methods}
\aliasA{initialize,ANY-method}{initialize-methods}{initialize,ANY.Rdash.method}
\aliasA{initialize,environment-method}{initialize-methods}{initialize,environment.Rdash.method}
\aliasA{initialize,signature-method}{initialize-methods}{initialize,signature.Rdash.method}
\aliasA{initialize,traceable-method}{initialize-methods}{initialize,traceable.Rdash.method}
\keyword{methods}{initialize-methods}
\keyword{programming}{initialize-methods}
%
\begin{Description}\relax
The arguments to function \code{\LinkA{new}{new}} to create an object from a
particular class can be interpreted specially for that class, by the
definition of a method for function \code{initialize} for the class.
This documentation describes some existing methods, and also outlines
how to write new ones.
\end{Description}
%
\begin{Section}{Methods}
\begin{description}

\item[\code{signature(.Object = "ANY")}] 
The default method for \code{initialize} takes either named or
unnamed arguments.  Argument names must be the names of slots in
this class definition, and the corresponding arguments must be
valid objects for the slot (that is, have the same class as
specified for the slot, or some superclass of that class).  If the
object comes from a superclass, it is not coerced strictly, so
normally it will retain its current class (specifically,
\code{\LinkA{as}{as}(object, Class, strict = FALSE)}).

Unnamed arguments must be objects of this class, of one of its
superclasses, or one of its subclasses (from the class, from a
class this class extends, or from a class that extends this
class). If the object is from a superclass, this normally defines
some of the slots in the object.  If the object is from a
subclass, the new object is that argument, coerced to the current
class.

Unnamed arguments are processed first, in the order they appear.
Then named arguments are processed.  Therefore, explicit values
for slots always override any values inferred from superclass or
subclass arguments.


\item[\code{signature(.Object = "traceable")}] 
Objects of a class that extends \code{traceable} are used to
implement debug tracing (see class \LinkA{traceable}{traceable.Rdash.class} and
\code{\LinkA{trace}{trace}}).

The \code{initialize} method for these classes takes special
arguments \code{def, tracer, exit, at, print}.  The first of these
is the object to use as the original definition (e.g., a
function).  The others correspond to the arguments to
\code{\LinkA{trace}{trace}}.


\item[\code{signature(.Object = "environment")}] 
The \code{initialize} method for environments takes a named list
of objects to be used to initialize the environment.


\item[\code{signature(.Object = "signature")}] 
This is a method for internal use only.
It takes an optional \code{functionDef} argument to provide a
generic function with a \code{signature} slot to define the
argument names.  See \LinkA{Methods}{Methods} for details.


\end{description}

\end{Section}
%
\begin{Section}{Writing Initialization Methods}
Initialization methods provide a general mechanism corresponding to
generator functions in other languages.

The arguments to \code{\LinkA{initialize}{initialize}} are \code{.Object} and
\dots. Nearly always, \code{initialize} is called from \code{new},
not directly.  The \code{.Object} argument is then the
prototype object from the class.

Two techniques are often appropriate for \code{initialize} methods:
special argument names and \code{callNextMethod}.

You may want argument names that are more natural to your users than
the (default) slot names.  These will be the formal arguments to
your method definition, in addition to \code{.Object} (always) and
\dots (optionally).  For example, the method for class
\code{"traceable"} documented above would be created by a call to
\code{\LinkA{setMethod}{setMethod}} of the form:

\begin{alltt}
    setMethod("initialize", "traceable",
      function(.Object, def, tracer, exit, at, print) ...
    )
  \end{alltt}


In this example, no other arguments are meaningful, and the resulting
method will throw an error if other names are supplied.

When your new class extends another class, you may want to call the
initialize method for this superclass (either a special method or the
default).  For example, suppose you want to define a method for your
class, with special argument \code{x}, but you also want users to be
able to set slots specifically.  If you want \code{x} to override the
slot information, the beginning of your method definition might look
something like this:

\begin{alltt}
    function(.Object, x, ...) \{
      Object <- callNextMethod(.Object, ...)
      if(!missing(x)) \{ # do something with x
  \end{alltt}


You could also choose to have the inherited method override, by first
interpreting \code{x}, and then calling the next method.

\end{Section}
\inputencoding{latin1}
\HeaderA{is}{Is an Object from a Class}{is}
\aliasA{extends}{is}{extends}
\aliasA{setIs}{is}{setIs}
\keyword{programming}{is}
\keyword{classes}{is}
\keyword{methods}{is}
%
\begin{Description}\relax
Functions to test inheritance relationships between an object and a
class (\code{is}) or between two classes (\code{extends}), and to
establish such relationships (\code{setIs}, an explicit alternative
to the \code{contains=} argument to \code{\LinkA{setClass}{setClass}}).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
is(object, class2)

extends(class1, class2, maybe = TRUE, fullInfo = FALSE)

setIs(class1, class2, test=NULL, coerce=NULL, replace=NULL,
      by = character(), where = topenv(parent.frame()), classDef =,
      extensionObject = NULL, doComplete = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] any \R{} object.
\item[\code{class1, class2}] 
the names of the classes between which \code{is} relations are to be
examined defined, or (more efficiently) the class definition
objects for the classes.

\item[\code{maybe, fullInfo}] 
In a call to \code{extends}, \code{maybe} is the value returned if
a relation is conditional. In a call with \code{class2} missing,
\code{fullInfo} is a flag, which if \code{TRUE} causes a list of
objects of class \code{classExtension} to be returned, rather than
just the names of the classes.

\item[\code{test, coerce, replace}] 
In a call to \code{setIs}, functions optionally supplied to test
whether the relation is defined, to coerce the object to
\code{class2}, and to alter the object so that \code{is(object, class2)}
is identical to \code{value}.  See the details section below.

The remaining arguments are for internal use and/or usually omitted.

\item[\code{extensionObject}]  alternative to the \code{test, coerce,
    replace, by} arguments; an object from class
\code{SClassExtension} describing the relation.  (Used in internal calls.)

\item[\code{doComplete}] when \code{TRUE}, the class definitions will be
augmented with indirect relations as well.  (Used in internal calls.)
\item[\code{by}] 
In a call to \code{setIs}, the name of an intermediary class.
Coercion will proceed by first coercing to this class and from there
to the target class.  (The intermediate coercions have to be valid.)
\item[\code{where}] 
In a call to \code{setIs}, where to store the metadata defining the
relationship.  Default is the global environment for calls from the
top level of the session or a source file evaluated there.  When the
call occurs in the top level of a file in the source of a package,
the default will be the name space or environment of the package.
Other uses are tricky and not usually a good idea, unless you really
know what you are doing.
\item[\code{classDef}] 
Optional class definition for \code{class} , required internally
when \code{setIs} is called during the initial definition of the
class by a call to \code{\LinkA{setClass}{setClass}}. \emph{Don't} use this
argument, unless you really know why you're doing so.
\end{ldescription}
\end{Arguments}
%
\begin{Section}{Summary of Functions}
\begin{description}

\item[\code{is}:] 
With two arguments, tests whether \code{object} can be treated as from
\code{class2}.

With one argument, returns all the super-classes of this object's class.

\item[\code{extends}:] 
Does the first class extend the second class?
The call returns \code{maybe} if the extension includes a test.

When called with one argument, the value is a vector of the
superclasses of \code{class1}.  If argument \code{fullInfo}  is
\code{TRUE}, the call returns a named list of objects of class
\code{\LinkA{SClassExtension}{SClassExtension.Rdash.class}}; otherwise, just the names of
the superclasses.

\item[\code{setIs}:] 
Defines \code{class1} to be an extension (subclass) of
\code{class2}.
If \code{class2} is an existing virtual class, such as a class
union, then only the two classes need to be supplied in the
call, if the implied inherited methods work for \code{class1}.
See the details section below.

Alternatively, arguments \code{coerce} and \code{replace} should
be supplied, defining methods to coerce to the superclass and to
replace the part corresponding to the superclass. As discussed in
the details and other sections below, this form is often less
recommended than the corresponding call to \code{\LinkA{setAs}{setAs}}, to
which it is an alternative.


\end{description}

\end{Section}
%
\begin{Section}{Details}
Arranging for a class to inherit from another class is a key tool in
programming.  In \R{}, there are three basic techniques, the first two
providing what is called  ``simple'' inheritance, the preferred form:

\begin{enumerate}

\item 
By the \code{contains=} argument in a call to \code{\LinkA{setClass}{setClass}}.  This
is and should be the most common mechanism.  It arranges that the new
class contains all the structure of the existing class, and in
particular all the slots with the same class specified.  The
resulting class extension is defined to be \code{simple}, with
important implications for method definition (see the section on
this topic below).

\item 
Making \code{class1} a subclass of a virtual class
either by a call to \code{\LinkA{setClassUnion}{setClassUnion}} to make the
subclass a member of a new class union, or by a call to
\code{setIs} to add a class to an existing class union or as a new
subclass of an existing virtual class.  In either case, the
implication should be that methods defined for the class union or
other superclass all work correctly for the subclass.  This may
depend on some similarity in the structure of the subclasses or
simply indicate that the superclass methods are defined in terms
of generic functions that apply to all the subclasses.  These
relationships are also generally simple.


\item 
Supplying \code{coerce}  and \code{replace} arguments to \code{setAs}.
\R{} allows arbitrary inheritance relationships, using the same
mechanism for defining coerce methods by a call to
\code{\LinkA{setAs}{setAs}}.  The difference between the  two is simply
that \code{\LinkA{setAs}{setAs}} will require a call to \code{\LinkA{as}{as}}
for a conversion to take place, whereas after the call to
\code{\LinkA{setIs}{setIs}}, objects will be automatically converted to
the superclass.

The automatic feature is the dangerous part, mainly because it
results in the subclass potentially inheriting methods that do
not work.  See the section on inheritance below.  If the two
classes involved do not actually inherit a large collection of
methods, as in the first example below, the danger may be
relatively slight.

If the superclass inherits methods where the subclass has only a
default or remotely inherited method, problems are more likely.
In this case, a general
recommendation is to use the \code{\LinkA{setAs}{setAs}} mechanism
instead, unless there is a strong counter reason. Otherwise, be prepared to
override some of  the methods inherited.

\end{enumerate}


With this caution given, the rest of this section describes what
happens when \code{coerce=} and \code{replace=} arguments are supplied
to \code{setIs}.

The \code{coerce} and \code{replace} arguments are functions that
define how to coerce a \code{class1} object to \code{class2}, and
how to replace the part of the subclass object that corresponds to
\code{class2}.  The first of these is a function of one argument
(conventionally \code{from}) and the second of two arguments
(\code{from}, \code{value}).  For details, see the section on coerce
functions below .

When \code{by} is specified, the coerce process first coerces to
this class and then to \code{class2}.  It's unlikely you
would use the \code{by} argument directly, but it is used in defining
cached information about classes.

The value returned (invisibly) by
\code{setIs} is the revised class definition of \code{class1}.
\end{Section}
%
\begin{Section}{Coerce, replace, and test functions}

The  \code{coerce} argument is a function that turns a
\code{class1} object into a \code{class2} object.  The
\code{replace} argument is a function of two arguments that modifies a \code{class1}
object (the first argument) to replace the part of it that
corresponds to \code{class2} (supplied as \code{value}, the second
argument).  It then returns the modified object as the value of the
call.  In other words, it acts as a replacement method to
implement the expression \code{as(object, class2) <- value}.

The easiest way to think of the  \code{coerce} and \code{replace}
functions is by thinking of the case that  \code{class1}
contains \code{class2} in the usual sense, by including the slots of
the second class.  (To repeat, in this situation you would not call
\code{setIs}, but the analogy shows what happens when you do.)

The \code{coerce} function in this case would just make a
\code{class2} object by extracting the corresponding slots from the
\code{class1} object. The \code{replace} function would replace in
the \code{class1} object the slots corresponding to \code{class2},
and return the modified object as its value.

For additional discussion of these functions, see
the documentation of the
\code{\LinkA{setAs}{setAs}} function.  (Unfortunately, argument
\code{def} to that function corresponds to argument \code{coerce} here.)

The inheritance relationship can also be conditional, if a function is supplied as the
\code{test} argument.  This should be a function of one argument
that returns \code{TRUE} or \code{FALSE} according to whether the
object supplied satisfies the relation \code{is(object, class2)}.
Conditional relations between
classes are slightly deprecated because they cannot be implemented
as efficiently as ordinary relations and because they sometimes can
lead to confusion (in thinking about what methods are dispatched for
a particular function, for example).  But they can correspond to
distinctions such as two classes that have the same representation,
but with only one of them obeying certain additional constraints.
\end{Section}
%
\begin{Section}{Inherited methods}
A method written for a particular signature (classes matched to one
or more formal arguments to the function) naturally assumes that the
objects corresponding to the arguments can be treated as coming from
the corresponding classes.  The objects will have all the slots and
available methods for the classes.

The code that selects and dispatches the methods ensures that this
assumption is correct.  If the inheritance was ``simple'', that
is, defined by one or more uses of the \code{contains=} argument in
a call to \code{\LinkA{setClass}{setClass}}, no extra work is generally
needed.  Classes are inherited from the superclass, with the same
definition.

When inheritance is defined by a general call to
\code{setIs}, extra computations are required.  This form of
inheritance implies that the subclass does \emph{not} just contain
the slots of the superclass, but instead requires the explicit call
to the coerce and/or replace method.  To ensure correct computation,
the inherited method is supplemented by calls to \code{\LinkA{as}{as}}
before the body of the method is evaluated.

The calls to \code{\LinkA{as}{as}} generated in this case have the
argument \code{strict = FALSE}, meaning that extra information can
be left in the converted object, so long as it has all the
appropriate slots.  (It's this option that allows simple subclass
objects to be used without any change.)  When you are writing your
coerce method, you may want to take advantage of that option.

Methods inherited through non-simple extensions can result in ambiguities
or unexpected selections.  If \code{class2} is a specialized class
with just a few applicable methods, creating the inheritance
relation may have little effect on the behavior of \code{class1}.
But if \code{class2} is a class with many methods, you may
find that you now inherit some undesirable methods for
\code{class1}, in some cases, fail to inherit expected methods.
In the second example below, the non-simple inheritance from class
\code{"factor"} might be assumed to inherit S3 methods via that
class.  But the S3 class is ambiguous, and in fact is
\code{"character"} rather than \code{"factor"}.

For some generic functions, methods inherited by non-simple
extensions are either known to be invalid or sufficiently likely to
be so that the generic function has been defined to exclude such
inheritance.  For example \code{\LinkA{initialize}{initialize}} methods must
return an object of the target class; this is straightforward if the
extension is simple, because no change is made to the argument
object, but is essentially impossible.  For this reason, the generic
function insists on only simple extensions for inheritance.  See the
\code{simpleInheritanceOnly} argument to \code{\LinkA{setGeneric}{setGeneric}}
for the mechanism.  You can use this mechanism when defining new
generic functions.

If you get into problems with functions that do allow non-simple
inheritance, there are two basic choices.  Either
back off from the \code{setIs} call and settle for explicit coercing
defined by a call to \code{\LinkA{setAs}{setAs}}; or, define explicit
methods involving \code{class1} to override the bad inherited
methods.  The first choice is the safer, when there are serious
problems.

\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{selectSuperClasses}{selectSuperClasses}(cl)} has similar semantics as
\code{extends(cl)}, typically returning subsets of the latter.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

## Two examples of setIs() with coerce= and replace= arguments
## The first one works fairly well, because neither class has many
## inherited methods do be disturbed by the new inheritance

## The second example does NOT work well, because the new superclass,
## "factor", causes methods to be inherited that should not be.

## First example:
## a class definition (see \link{setClass} for class "track")
setClass("trackCurve", contains = "track",
         representation( smooth = "numeric"))
## A class similar to "trackCurve", but with different structure
## allowing matrices for the "y" and "smooth" slots
setClass("trackMultiCurve",
         representation(x="numeric", y="matrix", smooth="matrix"),
         prototype = structure(list(), x=numeric(), y=matrix(0,0,0),

                               smooth= matrix(0,0,0)))
## Automatically convert an object from class "trackCurve" into
## "trackMultiCurve", by making the y, smooth slots into 1-column matrices
setIs("trackCurve",
      "trackMultiCurve",
      coerce = function(obj) {
        new("trackMultiCurve",
            x = obj@x,
            y = as.matrix(obj@y),
            smooth = as.matrix(obj@smooth))
      },
      replace = function(obj, value) {
        obj@y <- as.matrix(value@y)
        obj@x <- value@x
        obj@smooth <- as.matrix(value@smooth)
        obj})




## Second Example:
## A class that adds a slot to "character"
setClass("stringsDated", contains = "character", representation(stamp="POSIXt"))

## Convert automatically to a factor by explicit coerce
setIs("stringsDated", "factor",
      coerce = function(from) factor(from@.Data),
      replace= function(from, value) {
                  from@.Data <- as.character(value); from })

ll <- sample(letters, 10, replace = TRUE)
ld <- new("stringsDated", ll, stamp = Sys.time())

levels(as(ld, "factor"))
levels(ld) # will be NULL--see comment in section on inheritance above.

## In contrast, a class that simply extends "factor" has no such ambiguities
setClass("factorDated", contains = "factor", representation(stamp="POSIXt"))
fd <- new("factorDated", factor(ll), stamp = Sys.time())
identical(levels(fd), levels(as(fd, "factor")))
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{isSealedMethod}{Check for a Sealed Method or Class}{isSealedMethod}
\aliasA{isSealedClass}{isSealedMethod}{isSealedClass}
\keyword{programming}{isSealedMethod}
\keyword{classes}{isSealedMethod}
\keyword{classes}{isSealedMethod}
\keyword{methods}{isSealedMethod}
%
\begin{Description}\relax
These functions check for either a method or a class that has been
\emph{sealed} when it was defined, and which therefore cannot be
re-defined.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
isSealedMethod(f, signature, fdef, where)
isSealedClass(Class, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}]  The quoted name of the generic function. 
\item[\code{signature}]  The class names in the method's signature, as
they would be supplied to \code{\LinkA{setMethod}{setMethod}}. 
\item[\code{fdef}]  Optional, and usually omitted:  the generic function
definition for \code{f}. 
\item[\code{Class}] The quoted name of the class.

\item[\code{where}] where to search for the method or class definition.  By
default, searches from the top environment of the call to
\code{isSealedMethod} or \code{isSealedClass}, typically the
global environment or the name space of a package containing a call
to one of the functions.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
In the \R{} implementation of classes and methods, it is possible to
seal the definition of either a class or a method.  The basic
classes (numeric and other types of vectors, matrix and array data)
are sealed.  So also are the methods for the primitive functions on
those data types.  The effect is that programmers cannot re-define
the meaning of these basic data types and computations.  More
precisely, for primitive functions that depend on only one data
argument, methods cannot be specified for basic classes.  For
functions (such as the arithmetic operators) that depend on two
arguments, methods can be specified if \emph{one} of those arguments
is a basic class, but not if both are.

Programmers can seal other class and method definitions by using the
\code{sealed} argument to \code{\LinkA{setClass}{setClass}} or \code{\LinkA{setMethod}{setMethod}}.
\end{Details}
%
\begin{Value}
The functions return \code{FALSE} if the method or class is not
sealed (including the case that it is not defined); \code{TRUE} if
it is.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
## these are both TRUE
isSealedMethod("+", c("numeric", "character"))
isSealedClass("matrix")

setClass("track",
            representation(x="numeric", y="numeric"))
## but this is FALSE
isSealedClass("track")
## and so is this
isSealedClass("A Name for an undefined Class")
## and so are these, because only one of the two arguments is basic
isSealedMethod("+", c("track", "numeric"))
isSealedMethod("+", c("numeric", "track"))


\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{language-class}{Classes to Represent Unevaluated Language Objects}{language.Rdash.class}
\aliasA{(-class}{language-class}{(.Rdash.class}
\aliasA{<\Rdash-class}{language-class}{<.Rdash..Rdash.class}
\aliasA{call-class}{language-class}{call.Rdash.class}
\aliasA{for-class}{language-class}{for.Rdash.class}
\aliasA{if-class}{language-class}{if.Rdash.class}
\aliasA{name-class}{language-class}{name.Rdash.class}
\aliasA{repeat-class}{language-class}{repeat.Rdash.class}
\aliasA{while-class}{language-class}{while.Rdash.class}
\aliasA{\{-class}{language-class}{.Rlbrace..Rdash.class}
\keyword{classes}{language-class}
%
\begin{Description}\relax
  The virtual class \code{"language"} and the specific
classes that extend it represent unevaluated objects, as produced for
example by the parser or by functions such as \code{\LinkA{quote}{quote}}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
### each of these classes corresponds to an unevaluated object
### in the S language.
### The class name can appear in method signatures,
### and in a few other contexts (such as some calls to as()).

"("
"<-"
"call"
"for"
"if"
"repeat"
"while"
"name"
"{"

### Each of the classes above extends the virtual class
"language"
\end{verbatim}
\end{Usage}
%
\begin{Section}{Objects from the Class}
\code{"language"} is a virtual class; no objects may be created from
it.

Objects from the other classes can be generated by a call to
\code{new(Class, ...)}, where \code{Class} is the quoted class name, and
the \dots arguments are either empty or a \emph{single} object that is
from this class (or an extension).
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[coerce] \code{signature(from = "ANY", to = "call")}.  A method
exists for \code{as(object, "call")}, calling \code{as.call()}. 

\end{description}


\end{Section}
\inputencoding{latin1}
\HeaderA{LinearMethodsList-class}{Class "LinearMethodsList"}{LinearMethodsList.Rdash.class}
\keyword{classes}{LinearMethodsList-class}
%
\begin{Description}\relax
A version of methods lists that has been `linearized'
for producing summary information.  The actual objects from class
\code{"MethodsList"} used for method dispatch are defined recursively
over the arguments involved.
\end{Description}
%
\begin{Section}{Objects from the Class}
The function \code{\LinkA{linearizeMlist}{linearizeMlist}} converts an ordinary methods
list object into the linearized form.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{methods}:] Object of class \code{"list"}, the method
definitions.
\item[\code{arguments}:] Object of class \code{"list"}, the
corresponding formal arguments, namely as many of the arguments
in the signature of the generic function as are active in the
relevant method table. 
\item[\code{classes}:] Object of class \code{"list"}, the
corresponding classes in the signatures. 
\item[\code{generic}:] Object of class \code{"genericFunction"};
the generic function to which the methods correspond. 

\end{description}

\end{Section}
%
\begin{Section}{Future Note}
The current version of \code{linearizeMlist} does not take advantage of
the \code{MethodDefinition} class, and therefore does more work for less
effect than it could.  In particular, we may move to redefine both the
function and the class to take advantage of the stored signatures.
Don't write code depending precisely on the present form, although all
the current information will be obtainable in the future.
\end{Section}
%
\begin{SeeAlso}\relax
 Function \code{\LinkA{linearizeMlist}{linearizeMlist}} for the computation,
and class \code{\LinkA{MethodsList}{MethodsList.Rdash.class}} for the original, recursive
form.
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{makeClassRepresentation}{Create a Class Definition}{makeClassRepresentation}
\keyword{programming}{makeClassRepresentation}
\keyword{classes}{makeClassRepresentation}
%
\begin{Description}\relax
Constructs an object of class \code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}
to describe a particular class.  Mostly a utility function, but you can
call it to create a class definition without assigning it, as
\code{\LinkA{setClass}{setClass}} would do.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
makeClassRepresentation(name, slots=list(), superClasses=character(),
                        prototype=NULL, package, validity, access,
                        version, sealed, virtual=NA, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}] character string name for the class
\item[\code{slots}] named list of slot classes as would be supplied to
\code{setClass}, but \emph{without} the unnamed arguments for
superClasses if any.
\item[\code{superClasses}] what classes does this class extend
\item[\code{prototype}] an object providing the default data for the class,
e.g, the result of a call to \code{\LinkA{prototype}{prototype}}.
\item[\code{package}] The character string name for the package in which
the class will be stored; see \code{\LinkA{getPackageName}{getPackageName}}.
\item[\code{validity}] Optional validity method.  See
\code{\LinkA{validObject}{validObject}}, and the discussion of validity methods in
the reference.
\item[\code{access}] Access information.  Not currently used.
\item[\code{version}] Optional version key for version control.  Currently
generated, but not used.
\item[\code{sealed}] Is the class sealed? See \code{\LinkA{setClass}{setClass}}.
\item[\code{virtual}] Is this known to be a virtual class?

\item[\code{where}] The environment from which to look for class
definitions needed (e.g., for slots or superclasses). See the
discussion of this argument under \LinkA{GenericFunctions}{GenericFunctions}.
\end{ldescription}
\end{Arguments}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{setClass}{setClass}}
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{method.skeleton}{Create a Skeleton File for a New Method}{method.skeleton}
\keyword{programming}{method.skeleton}
\keyword{methods}{method.skeleton}
%
\begin{Description}\relax
This function writes a source file containing a call to
\code{\LinkA{setMethod}{setMethod}} to define a method for the generic function
and signature supplied.  By default the method definition is in line
in the call, but can be made an external (previously assigned) function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
method.skeleton(generic, signature, file, external = FALSE, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{generic}] the character string name of the generic function, or
the generic function itself.  In the first case, the function
need not currently be a generic, as it would not for the
resulting call to \code{\LinkA{setMethod}{setMethod}}.
\item[\code{signature}] the method signature, as it would be given to \code{\LinkA{setMethod}{setMethod}}
\item[\code{file}] a character string name for the output file, or a
writable connection.  By default the generic function name and
the classes in the signature are concatenated, with separating
underscore characters.  The file name should normally end in \code{".R"}. 

To write multiple method skeletons to one file, open the file
connection first and then pass it to \code{method.skeleton()} in
multiple calls.
\item[\code{external}] flag to control whether the function definition for
the method should be a separate external object assigned in the
source file, or included in line in the call to
\code{\LinkA{setMethod}{setMethod}}.
If supplied as a character string, this will be used as the name
for the external function; by default the name concatenates the
generic and signature names, with separating underscores.
\item[\code{where}] The environment in which to look for the function; by default,
the top-level environment of the call to \code{method.skeleton}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The \code{file} argument, invisibly, but the function is used for its side effect.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{setMethod}{setMethod}}, \code{\LinkA{package.skeleton}{package.skeleton}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

setClass("track", representation(x ="numeric", y="numeric"))
method.skeleton("show", "track")            ## writes show_track.R
method.skeleton("Ops", c("track", "track")) ## writes "Ops_track_track.R"

## write multiple method skeletons to one file
con <- file("./Math_track.R", "w")
method.skeleton("Math", "track", con)
method.skeleton("exp", "track", con)
method.skeleton("log", "track", con)
close(con)

\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{MethodDefinition-class}{Classes to Represent Method Definitions}{MethodDefinition.Rdash.class}
\aliasA{SealedMethodDefinition-class}{MethodDefinition-class}{SealedMethodDefinition.Rdash.class}
\keyword{classes}{MethodDefinition-class}
%
\begin{Description}\relax
These classes extend the basic class \code{"function"} when
functions are to be stored and used as method definitions.
\end{Description}
%
\begin{Details}\relax
Method definition objects are functions with additional information
defining how the function is being used as a method.  The
\code{target} slot is the class signature for which the method will
be dispatched, and the \code{defined} slot the signature for which
the method was originally specified (that is, the one that appeared
in some call to \code{\LinkA{setMethod}{setMethod}}).
\end{Details}
%
\begin{Section}{Objects from the Class}
The action of setting a method by a call to \code{\LinkA{setMethod}{setMethod}} creates an object of this class.  It's
unwise to create them directly.

The class \code{"SealedMethodDefinition"} is created by a call to
\code{\LinkA{setMethod}{setMethod}} with argument \code{sealed = TRUE}.  It has
the same representation as \code{"MethodDefinition"}.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] Object of class \code{"function"}; the data
part of the definition. 
\item[\code{target}:] Object of class \code{"signature"}; the
signature for which the method was wanted. 
\item[\code{defined}:] Object of class \code{"signature"}; the
signature for which a method was found.  If the method was
inherited, this will not be identical to \code{target}. 
\item[\code{generic}:] Object of class \code{"character"}; the function
for which the method was created. 

\end{description}

\end{Section}
%
\begin{Section}{Extends}
Class \code{"function"}, from data part.\\{}
Class \code{"PossibleMethod"}, directly.\\{}
Class \code{"OptionalMethods"}, by class \code{"function"}.
\end{Section}
%
\begin{SeeAlso}\relax
class \code{\LinkA{MethodsList}{MethodsList.Rdash.class}} for the objects
defining sets of methods associated with a particular generic
function.  The individual method definitions stored in these objects
are from class \code{MethodDefinition}, or an extension.
Class \code{\LinkA{MethodWithNext}{MethodWithNext.Rdash.class}} for an extension used by
\code{\LinkA{callNextMethod}{callNextMethod}}.
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{Methods}{General Information on Methods}{Methods}
\keyword{programming}{Methods}
\keyword{classes}{Methods}
\keyword{methods}{Methods}
%
\begin{Description}\relax
This documentation section covers some general topics on how methods
work and how the \pkg{methods} package interacts with the rest of R.  The
information is usually not needed to get started with methods and
classes, but may be helpful for moderately ambitious projects, or when
something doesn't work as expected.

The section ``How Methods Work'' describes the underlying
mechanism; ``S3 Methods'' gives the rules applied when S4
classes and methods interact with older S3 methods; ``Method Selection and Dispatch'' provides more
details on how class definitions determine which methods are used;
``Generic Functions'' discusses generic functions as objects.
For additional information specifically about class definitions, see \code{\LinkA{Classes}{Classes}}.
\end{Description}
%
\begin{Section}{How Methods Work}
A generic function  has associated with it a
collection of other functions (the methods), all of which have the same
formal arguments as the generic.  See the ``Generic
Functions'' section below for more on generic functions themselves.

Each R package will include  methods metadata objects
corresponding to each generic function  for which methods have been
defined in that package.
When the package is loaded into an R session, the methods for each
generic function are \emph{cached}, that is, stored in the
environment of the generic function along with the methods from
previously loaded packages.  This merged table of methods is used to
dispatch or select methods from the generic, using class inheritance
and possibly group generic functions (see
\code{\LinkA{GroupGenericFunctions}{GroupGenericFunctions}}) to find an applicable method.
See the ``Method Selection and Dispatch'' section below.
The caching computations ensure that only one version of each
generic function is visible globally; although different attached
packages may contain a copy of the generic function, these behave
identically with respect to method selection.
In contrast, it is possible for the same function name to refer to
more than one generic function, when these have different
\code{package} slots.  In the latter case, \R{} considers the
functions unrelated:  A generic function is defined by the
combination of name and package.  See the ``Generic Functions''
section below.

The methods for a generic are stored according to the
corresponding \code{signature} in the call to \code{\LinkA{setMethod}{setMethod}}
that defined  the method.  The signature associates one
class name with each of a subset of the formal arguments to the
generic function.  Which formal arguments are available, and the
order in which they appear, are determined by the \code{"signature"}
slot of the generic function itself.  By default, the signature of the
generic consists of all the formal arguments except \dots, in the
order they appear in the function definition.

Trailing arguments in the signature of the generic will be \emph{inactive}  if no
method has yet been specified that included those arguments in its signature.
Inactive arguments are not needed or used in labeling the cached
methods.  (The distinction does not change which methods are
dispatched, but ignoring inactive arguments improves the
efficiency of dispatch.)

All arguments in the signature of the generic function will be evaluated when the
function is called, rather than using the traditional lazy
evaluation rules of S.  Therefore, it's important to \emph{exclude}
from the signature any arguments that need to be dealt with
symbolically (such as the first argument to function
\code{\LinkA{substitute}{substitute}}).  Note that only actual arguments are
evaluated, not default expressions.
A missing argument enters into the method selection as class
\code{"missing"}.

The cached methods are stored in an
environment object.  The names used for assignment are a
concatenation of the class names for the active arguments in the method signature.

\end{Section}
%
\begin{Section}{S3 Methods}

The functions for which S4 methods will be written often include some
for which S3 methods exist, corresponding to S3 classes for the first
formal argument of an S3 generic function or of a primitive function, or for either of the
arguments in a call to one of the primitive binary operators.
In the case of true functions, S3 methods will be dispatched
by the original version of the function.  The usual
way this happens is by the function becoming the default
method for the S4 generic, implicitly by a call to
\code{\LinkA{setMethod}{setMethod}} or explicitly by the call

\code{setGeneric("f")}

where the original \code{f()} contained the call
\code{UseMethod("f")}.
The S4 method selection code matches the classes of the arguments as
described in the previous section.
Matching will be applied for the class of S3 objects as well as S4
objects, but only the first string in an S3 class attribute is used.
If no non-default S4 method
matches the call,  the default S4 method can then operate as an S3
generic to select S3 methods for \code{f()}.

Primitive functions and operators dispatch both S4 and S3 methods from
the internal C code.
The method selection mechanism works essentially the same way, with
two exceptions.
There is no explicit generic function, either S3 or S4, meaning that
the selection of an S3 method if no S4 method is found is built in and
not a result of an explicit default method.
Also, the internal code does not look for S4 methods unless the first
argument or one of the arguments to an operator is an S4 object.
S4 methods can be defined for an S3 generic function and an S3 class.
But if the function is a primitive, such methods will not be selected
if the object in question is not an S4 object.
In the examples below, for instance,  an S4 method for signature
\code{"data.frame"} for function \code{f3()} would be called for the
S3 object \code{df1}.
A similar S4 method for primitive function
\code{`[`} would be ignored for that object, but would be called for
the S4 object \code{mydf1} that inherits from \code{"data.frame"}.
It's an unfortunate inconsistency, but enforced by the passion for
efficiency in dispatching methods for primitives.


The common case is that objects from S4 classes will use S4 methods,
except when the function's default definition is wanted.  For example,
if an S4 class extends one of the basic object types the base code for
that type may do what we want.
Objects not from an S4 class will continue to follow S3 method selection.

The rest of this section describes S3 method selection in two special cases.
In one case, the S4 class contains an S3 class (and has ensured that
objects have all the structure needed for the S3 class).
In the second case, S3 methods have been written for an S4 class;
that is, a function \emph{f.class}, where \emph{f} is an S3 generic
function and \emph{class} is the name of an S4 class, other than a
registered S3 class.
The first case is now supported and recommended, the second case is
discouraged, but occasionally needed (see section 4 of the paper in
the references).

The following rules define selection of an S3 method for an S4
object.  S4 objects are defined internally by a bit in the C
structure.  In practice, any object generated from an S4 class will be
an S4 object, as well as the result of most computations
on such objects.  Older computations defined for non-S4 classes or
object types may or may not return S4 objects when the arguments are
such objects.

An S3 method will be selected applying the following criteria in order:
\begin{enumerate}


\item 
the \emph{class} for the method matches the name of the S4 class
exactly;


\item 
the object has a slot \code{".S3Class"} and \emph{class} is selected
by S3 inheritance, treating that slot as the S3 class of the object;


\end{enumerate}

The second criterion will apply if either the S4 class contains an S3
class or the argument \code{S3methods=TRUE} was given to
\code{\LinkA{setClass}{setClass}} for the class of the object or for one of its
superclasses.


If an S4 class extends an S3 class, and if no S4 methods take precedence, we expect that the
correct S3 method for the inherited S3 class will be chosen.
This will happen, so long as the S3 class has been registered by a
call to \code{\LinkA{setOldClass}{setOldClass}}.
If so, the object from the S4 class will inherit a special slot
that will be used as the class for S3 dispatch.  Effectively, this
slot is a proxy for the class attribute expected by S3 dispatch.  It
can even vary in its inheritance between objects, as happens with some
S3 classes, such as \code{\LinkA{POSIXt}{POSIXt}}, if the replacement version
of \code{\LinkA{S3Class}{S3Class}} is used to set it.
If the class so selected is one of the basic S3 classes,
the object is converted to an S3 object
with this vector as its class attribute.

A second nonstandard situation arises when an S3 method has been
explicitly written for an S4 class.
Versions of R through 2.9.0 did not recognize S4
inheritance in dispatching S3 methods, so that subclasses of the S4 class
would not then inherit the S3 method.  The version of \R{} accompanying this documentation
fixes this problem, to the extent practical, as follows.
S3 method selection will
resemble S4 selection for the same class \emph{if} the call to
\code{\LinkA{setClass}{setClass}} has included the argument \code{S3methods =
  TRUE}. If not, the current behavior (R 2.9.1) is to select S3 methods
defined for this class, but not for its subclasses  (largely for back compatibility; in future versions of R, S3 methods may be
ignored for S4 classes unless \code{S3methods} is set.)
The implementation uses the same special slot as above for inheriting
from an S3 class.  Subclasses of a class set this way will inherit the
same special slot and the same S3 method selection.
It's even possible to set the slot in individual objects, as above,
but the possibilities for confusion are serious.


Looking in the other direction, it remains true that S4 selection has no
knowledge of S3 methods.
This can cause problems when a class that expects to inherit
the S3 method, \code{"classA"} in the example below, also inherits from another S4
class.  If that class inherits an S4 method for a function, no matter how
indirectly, that S4 method will be selected for an object from
\code{"classA"}, even though there is a directly defined S3 method.
The S3 method can only be accessed through the default S4 method.
These problems are relatively unlikely to occur, but anyone defining a
class that extends both S3 and S4 classes needs to be careful.

\end{Section}
%
\begin{Section}{Method Selection and Dispatch: Details}

When a call to a generic function is evaluated, a method is selected corresponding
to the classes of the actual arguments in the signature.
First, the cached methods table is searched for an  exact match;
that is, a method stored under the signature defined by
the string value of \code{class(x)} for each non-missing
argument, and \code{"missing"} for each missing argument.
If no method is found directly for the actual arguments in a call to a
generic function, an attempt is made to match the available methods to
the arguments by using the superclass information about the actual classes.

Each class definition may include a list of  one or more
\emph{superclasses} of the new class.
The simplest and most common specification is by the \code{contains=} argument in
the  call to \code{\LinkA{setClass}{setClass}}.
Each class named in this argument is a superclass of the new class.
The S language has two additional mechanisms for defining
superclasses.
A call to 
\code{\LinkA{setIs}{setIs}} can create an inheritance relationship that is not the simple one of
containing the superclass representation in the new class.
In this case, explicit methods are defined to relate the subclass and
the superclass.
Also, a call to \code{\LinkA{setClassUnion}{setClassUnion}} creates a union class that
is a
superclass of each of the members of the union.
All three mechanisms are treated equivalently for purposes of
method selection:  they define the \emph{direct} superclasses of a
particular class.
For more details on the mechanisms, see \code{\LinkA{Classes}{Classes}}.

The direct superclasses themselves may
have superclasses, defined by any of the same mechanisms, and
similarly for further generations.  Putting all this information together produces
the full list of superclasses for this class.
The superclass list is included in the definition of the class that is
cached during the R session.
Each element of the list describes the nature of the relationship (see
\code{\LinkA{SClassExtension}{SClassExtension.Rdash.class}} for details).
Included in the element is a \code{distance} slot giving a numeric
distance between the two classes.
The distance is the path length for the relationship:
\code{1} for direct superclasses (regardless of which mechanism
defined them), then \code{2} for the direct superclasses of those
classes, and so on.
In addition, any class implicitly has class \code{"ANY"} as a superclass.  The
distance to \code{"ANY"} is treated as larger than the distance to any
actual class.
The special class \code{"missing"} corresponding to missing arguments
has only \code{"ANY"} as a superclass, while \code{"ANY"} has no
superclasses.

When a class definition is created or modified, the superclasses
are ordered, first by a stable sort of the all superclasses by
distance.
If the set of superclasses has duplicates (that is, if some class is
inherited through more than one relationship), these are removed, if
possible, so that the list of superclasses is consistent with the
superclasses of all direct superclasses.
See the reference on inheritance for details.

The information about superclasses is summarized when a class
definition is printed.

When a method is to be selected by inheritance, a search is made in
the table for all methods directly corresponding to a combination of
either the direct class or one of its superclasses, for each argument
in the active signature.
For an example, suppose there is only one argument in the signature and that the class of
the corresponding object was \code{"dgeMatrix"} (from the recommended package
\code{Matrix}).
This class has two direct superclasses and through these 4 additional superclasses.
Method selection finds all the methods in the table of directly
specified methods labeled by one of these classes, or by
\code{"ANY"}.

When there are multiple arguments in the signature, each argument will
generate a similar  list of inherited classes.
The possible matches are now all the combinations of classes from each
argument (think of the function \code{outer} generating an array of
all possible combinations).
The search now finds all the methods matching any of this combination
of classes.
For each argument, the position in the list of superclasses of that
argument's class defines which method or methods (if the same class
appears more than once) match best.
When there is only one argument, the best match is unambiguous.
With more than one argument, there may be zero or one match that is
among the best matches for \emph{all} arguments.

If there is no best match, the selection is ambiguous and a message is
printed noting which method was selected (the first method
lexicographicaly in the ordering) and what other methods could have
been selected.
Since the ambiguity is usually nothing the end user could control,
this is not a warning.
Package authors should examine their package for possible ambiguous
inheritance by calling \code{\LinkA{testInheritedMethods}{testInheritedMethods}}.

When the inherited method has been selected, the selection is cached
in the generic function so that future calls with the same class will
not require repeating the search.  Cached inherited selections are
not themselves used in future inheritance searches, since that could result
in invalid selections.
If you want inheritance computations to be done again (for example,
because a newly loaded package has a more direct method than one
that has already been used in this session), call
\code{\LinkA{resetGeneric}{resetGeneric}}.  Because classes and methods involving
them tend to come from the same package, the current implementation
does not reset all generics every time a new package is loaded.

Besides being initiated through calls to the generic function, method
selection can be done explicitly by calling the function
\code{\LinkA{selectMethod}{selectMethod}}.

Once a method has been selected, the evaluator creates a new context
in which a call to the method is evaluated.
The context is initialized with the arguments from the call to the
generic function.
These arguments are not rematched.  All the arguments in the signature
of the generic will have been evaluated (including any that are
currently inactive); arguments that are not in the signature will obey
the usual lazy evaluation rules of the language.
If an argument was missing in the call, its default expression if any
will \emph{not} have been evaluated, since method dispatch always uses
class \code{missing} for such arguments.

A call to a generic function therefore has two contexts:  one for the
function and a second for the method.
The argument objects will be copied to the second context, but not any
local objects created in a nonstandard generic function.
The other important distinction is that the parent 
(``enclosing'') environment of the second context is the environment
of the method as a function, so that all \R{} programming techniques
using such environments apply to method definitions as ordinary functions.


For further discussion of method selection and dispatch,  see the
first reference.

\end{Section}
%
\begin{Section}{Generic Functions}
In principle, a generic function could be any function that evaluates
a call to \code{standardGeneric()}, the internal function that selects
a method and evaluates a call to  the selected method.  In practice,
generic functions are special objects that in addition to being from a
subclass of class \code{"function"} also extend the class
\code{\LinkA{genericFunction}{genericFunction.Rdash.class}}.  Such objects have slots to define
information needed to deal with their methods.  They also have
specialized environments, containing the tables used in method
selection.

The slots \code{"generic"} and  \code{"package"} in the object are the
character string names of the generic function itself and of the
package from which the  function is defined.
As with classes, generic functions are uniquely defined in \R{} by the
combination of the two names.
There can be generic functions of the same name associated with
different packages (although inevitably keeping such functions cleanly
distinguished is not always easy).
On the other hand, \R{} will enforce that only one definition of a
generic function can be associated with a particular combination of
function and package name, in the current session or other active
version of \R{}.

Tables of methods for a particular generic function, in this sense,
will often be spread over several other packages.
The total set of methods for a given generic function may change
during a session, as additional packages are loaded.
Each table must be consistent in the signature assumed for the generic
function.

\R{} distinguishes \emph{standard} and \emph{nonstandard} generic
functions, with the former having a function body that does nothing
but dispatch a method.
For the most part, the distinction is just one of simplicity:  knowing
that a generic function only dispatches a method call allows some
efficiencies and also removes some uncertainties.

In most cases, the generic function is the visible function
corresponding to that name, in the corresponding package.
There are two exceptions, \emph{implicit} generic
functions and the special computations required to deal with \R{}'s
\emph{primitive} functions.
Packages can contain a table of implicit generic versions of functions
in the package, if the package wishes to leave a function non-generic
but to constrain what the function would be like if it were generic.
Such implicit generic functions are created during the installation of
the package, essentially by defining the generic function and
possibly methods for it, and then reverting the function to its
non-generic form. (See \LinkA{implicitGeneric}{implicitGeneric} for how this is done.)
The mechanism is mainly used for functions in the older packages in
\R{}, which may prefer to ignore S4 methods.
Even in this case, the actual mechanism is only needed if something
special has to be specified.
All functions have a corresponding implicit generic version defined
automatically (an implicit, implicit generic function one might say).
This function is a standard generic with the same arguments as the
non-generic function, with the non-generic version as the default (and only)
method, and with the generic signature being all the formal arguments
except \dots.

The implicit generic mechanism is needed only to override some aspect
of the default definition.
One reason to do so would be to remove some arguments from the
signature.
Arguments that may need to be interpreted literally, or for which the
lazy evaluation mechanism of the language is needed, must \emph{not}
be included in the signature of the generic function, since all
arguments in the signature will be evaluated in order to select a
method.
For example, the argument \code{expr} to the function
\code{\LinkA{with}{with}} is treated literally and must therefore be excluded
from the signature.

One would also need to define an implicit generic if the existing
non-generic function were not suitable as the default method.
Perhaps the function only applies to some classes of objects, and the
package designer prefers to have no general default method.
In the other direction, the package designer might have some ideas
about suitable methods for some classes, if the function were generic.
With reasonably modern packages, the simple approach in all these
cases is just to define the function as a generic.
The implicit generic mechanism is mainly attractive for older packages
that do not want to require the methods package to be available.

Generic functions will also be defined but not obviously visible for
functions implemented as \emph{primitive} functions in the base
package.
Primitive functions look like ordinary functions when printed but are
in fact not function objects but objects of two types interpreted by
the \R{} evaluator to call underlying C code directly.
Since their entire justification is efficiency, \R{} refuses to hide
primitives behind a generic function object.
Methods may be defined for most primitives, and corresponding metadata
objects will be created to store them.
Calls to the primitive still go directly to the C code, which will
sometimes check for applicable methods.
The definition of ``sometimes'' is that methods must have been
detected for the function in some package loaded in the session and
\code{isS4(x)} is \code{TRUE} for  the first argument (or for the
second argument, in the case of binary operators).
You can test whether methods have been detected by calling
\code{\LinkA{isGeneric}{isGeneric}} for the relevant function and you can examine
the generic function by calling \code{\LinkA{getGeneric}{getGeneric}}, whether or
not methods have been detected.
For more on generic functions, see the first reference and also section 2 of \emph{R Internals}.

\end{Section}
%
\begin{Section}{Method Definitions}
All method definitions are stored as objects from the
\code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}} class.
Like the class of generic functions, this class extends ordinary \R{}
functions with some additional slots: \code{"generic"}, containing the
name and package of the generic function, and two signature slots,
\code{"defined"} and \code{"target"}, the first being the signature supplied when
the method was defined by a call to \code{\LinkA{setMethod}{setMethod}}.
The  \code{"target"} slot starts off equal to the \code{"defined"}
slot.  When an inherited method is cached after being selected, as
described above, a copy is made with the  appropriate \code{"target"}  signature.
Output from \code{\LinkA{showMethods}{showMethods}}, for example, includes both
signatures.

Method definitions are required to have the same formal arguments as
the generic function, since the method dispatch mechanism does not
rematch arguments, for reasons of both efficiency and consistency.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version: see section 10.6 for method
selection and section 10.5 for generic functions).

Chambers, John M.(2009)
\emph{Developments in Class Inheritance and Method Selection}
\url{http://stat.stanford.edu/~jmc4/classInheritance.pdf}.

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
For more specific information, see
\code{\LinkA{setGeneric}{setGeneric}}, \code{\LinkA{setMethod}{setMethod}}, and
\code{\LinkA{setClass}{setClass}}.

For the use of \dots in methods, see  \LinkA{dotsMethods}{dotsMethods}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## The rules for inheriting S3 methods.

f3 <- function(x)UseMethod("f3") # an S3 generic to illustrate inheritance

## A class that extends a registered S3 class inherits that class' S3
## methods.  The S3 methods will be passed an object with the S3 class

setClass("myFrame", contains = "data.frame",
    representation(date = "POSIXt", type = "character"))

df1 <- data.frame(x = 1:10, y = rnorm(10), z = sample(letters,10))

mydf1 <- new("myFrame", df1, date = Sys.time())

## "myFrame" objects inherit "data.frame" S3 methods; e.g., for `[`

mydf1[1:2, ] # a data frame object (with extra attributes "date" and "type")



## Extending an S3 class with inconsistent (instance-based) inheritance
setClass("myDateTime", contains = "POSIXt")

now <- Sys.time() # class(now) is c("POSIXt", "POSIXct")
nowLt <- as.POSIXlt(now)# class(nowLt) is c("POSIXt", "POSIXlt")

mCt <- new("myDateTime", now)
mLt <- new("myDateTime", nowLt)

## S3 methods will be selected using instance-based information

f3.POSIXct <- function(x) "The POSIXct result"
f3.POSIXlt <- function(x) "The POSIXlt result"

stopifnot(identical(f3(mCt), f3.POSIXct(mCt)))
stopifnot(identical(f3(mLt), f3.POSIXlt(mLt)))



## An S4 class that does not contain a registered S3 class or object type
## selects S3 methods according to its S4 "inheritance"
## but only if the class definition requests this via S3methods=TRUE
## ( from version 2.9.1 on)

setClass("classA", contains = "numeric",
   representation(realData = "numeric"), S3methods = TRUE)

Math.classA <- function(x) {(getFunction(.Generic))(x@realData)}

x <- new("classA", log(1:10), realData = 1:10)

stopifnot(identical(abs(x), 1:10))

setClass("classB", contains = "classA")

y <- new("classB", x)

stopifnot(identical(abs(y), 1:10)) # (version 2.9.0 or earlier fails here)

## Note: with a class that tries to combine both S3 and S4 superclasses.
## The S3 inheritance is used and the S3 method for
## the S4 superclass will not be selected.

setClass("classC", representation(x = "numeric"))

# an S3 method for "[" (not a good idea, but it would work)
`[.classc` <- function(x, ..., drop = TRUE) {x@x[...]}


setClass("classD", contains = c("classC", "data.frame"))

## by the rule mentioned in the S3 method section, the
## S3 methods are selected from the S3 class defined; that is, "data.frame"
## If the user expected to inherit `[.classC`, no luck.
xd <- new("classD", df1, x = 1:50)

## Note the error from `[.data.frame`
try(xd[1:25])



\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{methods-deprecated}{Deprecated Functions in Methods package}{methods.Rdash.deprecated}
\aliasA{trySilent}{methods-deprecated}{trySilent}
\keyword{misc}{methods-deprecated}
%
\begin{Description}\relax
These functions are provided for compatibility with older versions of
\R{} only, and may be defunct as soon as the next release.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
trySilent(expr)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{expr}] an \R{} expression to try.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The original help page for these functions is often
available at \code{help("oldName-deprecated")} (note the quotes).
Functions in packages other than the methods package are listed in
\code{help("pkg-deprecated")}.

\code{trySilent(ex)} is a deprecated equivalent of \code{\LinkA{try}{try}(e,
    silent=TRUE)}; in \R{} programming it is typically more efficient and
flexible to work with something like \code{\LinkA{tryCatch}{tryCatch}(ex,
      error = function(e) e)} instead. 
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{Deprecated}{Deprecated}}, \code{\LinkA{methods-defunct}{methods.Rdash.defunct}}
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{MethodsList-class}{Class MethodsList, Representation of Methods for a Generic Function}{MethodsList.Rdash.class}
\aliasA{body<\Rdash,MethodDefinition-method}{MethodsList-class}{body<.Rdash.,MethodDefinition.Rdash.method}
\keyword{classes}{MethodsList-class}
\keyword{methods}{MethodsList-class}
%
\begin{Description}\relax
 Objects from this class are generated and revised by the
definition of methods for a generic function.
\end{Description}
%
\begin{Details}\relax
Suppose a function \code{f} has
formal arguments \code{x} and \code{y}.  The methods list object for
that function has the object \code{as.name("x")} as its
\code{argument} slot.  An element of the methods named \code{"track"}
is selected if the actual argument corresponding to \code{x} is an
object of class \code{"track"}.  If there is such an element, it can
generally be either a function or another methods list object.

In the first case, the function defines the method to use for any call
in which \code{x} is of class \code{"track"}.  In the second case, the
new methods list object defines the available methods depending on
the remaining formal arguments, in this example, \code{y}. 

Each method  corresponds conceptually to a \emph{signature};
that is a named list of classes, with names corresponding to some or
all of the formal arguments.  In the previous example, if selecting
class \code{"track"} for \code{x}, finding that the selection was
another methods list and then selecting class \code{"numeric"} for
\code{y} would produce a method associated with the signature
\code{x = "track", y = "numeric"}.

You can see the methods
arranged by signature by calling the function
\code{\LinkA{showMethods}{showMethods}}, 
A methods list can be converted into an ordinary list with the methods arranged this
way (in two different forms)  by calling the functions
\code{\LinkA{listFromMlist}{listFromMlist}} and \code{\LinkA{linearizeMlist}{linearizeMlist}}.

\end{Details}
%
\begin{Section}{Slots}
\begin{description}


\item[\code{argument}:] Object of class \code{"name"}.  The name of the
argument being used for dispatch at this level. 
\item[\code{methods}:] A named list of the methods (and method lists)
defined \emph{explicitly} for this argument. 
The names are the names of classes, and the corresponding
element defines the method or methods to be used if the corresponding
argument has that class.  See the details below.
\item[\code{allMethods}:] A named list,  contains
all the directly defined methods from the \code{methods} slot, plus
any inherited methods.  Ignored when methods tables are used for dispatch (see \LinkA{Methods}{Methods} 

\end{description}
\end{Section}
%
\begin{Section}{Extends}
Class \code{"OptionalMethods"}, directly.
\end{Section}
\inputencoding{latin1}
\HeaderA{MethodWithNext-class}{Class MethodWithNext}{MethodWithNext.Rdash.class}
\keyword{classes}{MethodWithNext-class}
%
\begin{Description}\relax
 Class of method definitions set up for callNextMethod 
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects from this class are generated as a side-effect of calls to
\code{\LinkA{callNextMethod}{callNextMethod}}.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] Object of class \code{"function"}; the actual
function definition.
\item[\code{nextMethod}:] Object of class \code{"PossibleMethod"}
the method to use in response to a \code{\LinkA{callNextMethod}{callNextMethod}()}
call.
\item[\code{excluded}:] Object of class \code{"list"}; one or more
signatures excluded in finding the next method. 
\item[\code{target}:] Object of class \code{"signature"}, from class
\code{"MethodDefinition"}
\item[\code{defined}:] Object of class \code{"signature"}, from
class \code{"MethodDefinition"}
\item[\code{generic}:] Object of class \code{"character"}; the function
for which the method was created. 

\end{description}

\end{Section}
%
\begin{Section}{Extends}
Class \code{"MethodDefinition"}, directly.\\{}
Class \code{"function"}, from data part.\\{}
Class \code{"PossibleMethod"}, by class \code{"MethodDefinition"}.\\{}
Class \code{"OptionalMethods"}, by class \code{"MethodDefinition"}.
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[findNextMethod] \code{signature(method = "MethodWithNext")}:
used internally by method dispatch. 
\item[loadMethod] \code{signature(method = "MethodWithNext")}: used
internally by method dispatch. 
\item[show] \code{signature(object = "MethodWithNext")} 

\end{description}

\end{Section}
%
\begin{SeeAlso}\relax
  \code{\LinkA{callNextMethod}{callNextMethod}}, and
class \code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}}.
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{new}{Generate an Object from a Class}{new}
\aliasA{initialize}{new}{initialize}
\keyword{programming}{new}
\keyword{classes}{new}
%
\begin{Description}\relax
Given the name or the definition of a class, plus optionally data
to be included in the object, \code{new} returns an object from that
class.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
new(Class, ...)

initialize(.Object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}]  Either the name of a class (the usual case) or the
object describing the class (e.g., the value returned by
\code{getClass}).
\item[\code{...}]  Data to include in the new object.  Named arguments
correspond to slots in the class definition. Unnamed arguments must
be objects from classes that this class extends.
\item[\code{.Object}]  An object:  see the Details section.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The function \code{new} begins by copying the prototype object from
the class definition.  Then information is inserted according to the
\code{...} arguments, if any.  As of version 2.4 of R, the type of
the prototype object, and therefore of all objects returned by
\code{new()}, is \code{"S4"} except for classes that extend
one of the basic types, where the prototype has that basic type.  User
functions that depend on \code{\LinkA{typeof}{typeof}(object)} should be
careful to handle \code{"S4"} as a possible type.

The interpretation of the \code{...} arguments can be specialized to
particular classes, if an appropriate method has been defined for the
generic function \code{"initialize"}.  The \code{new} function calls
\code{initialize} with the object generated from the prototype as the
\code{.Object} argument to \code{initialize}.

By default, unnamed arguments in the \code{...} are interpreted as
objects from a superclass, and named arguments are interpreted as
objects to be assigned into the correspondingly named slots.  Thus,
explicit slots override inherited information for the same slot,
regardless of the order in which the arguments appear.

The \code{initialize} methods do not have to have \code{...} as
their second argument (see the examples).  Initialize methods are
often written when the natural parameters describing the new object
are not the names of the slots.  If you do define such a method,
note the implications for future subclasses of your class.  If these
have additional slots, and your \code{initialize} method has
\code{...} as a formal argument, then your method should pass such
arguments along via \code{\LinkA{callNextMethod}{callNextMethod}}.  If your method
does not have this argument, then either a subclass must have its
own method or else the added slots must be specified by users in
some way other than as arguments to \code{new}.

For examples of \code{initialize} methods, see
\code{\LinkA{initialize-methods}{initialize.Rdash.methods}} for existing methods for
classes \code{"traceable"} and \code{"environment"}, among others.

Methods for \code{initialize} can be inherited only by simple
inheritance, since it is a requirement that the method return an
object from the target class.  See the
\code{simpleInheritanceOnly} argument to \code{\LinkA{setGeneric}{setGeneric}} and
the discussion in \code{\LinkA{setIs}{setIs}} for the general concept.

Note that the basic vector classes, \code{"numeric"}, etc. are
implicitly defined, so one can use \code{new} for these classes.
\end{Details}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.) 
\end{References}
%
\begin{SeeAlso}\relax
 \LinkA{Classes}{Classes} for an overview of defining class, and
\code{\LinkA{setOldClass}{setOldClass}} for the relation to S3 classes. 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## using the definition of class "track" from \link{Classes}



## a new object with two slots specified
t1 <- new("track", x = seq_along(ydata), y = ydata)

# a new object including an object from a superclass, plus a slot
t2 <- new("trackCurve", t1, smooth = ysmooth)

### define a method for initialize, to ensure that new objects have
### equal-length x and y slots.

setMethod("initialize",
          "track",
          function(.Object, x = numeric(0), y = numeric(0)) {
            if(nargs() > 1) {
              if(length(x) != length(y))
                stop("specified x and y of different lengths")
              .Object@x <- x
              .Object@y <- y
            }
            .Object
          })

### the next example will cause an error (x will be numeric(0)),
### because we didn't build in defaults for x,
### although we could with a more elaborate method for initialize

try(new("track", y = sort(stats::rnorm(10))))

## a better way to implement the previous initialize method.
## Why?  By using callNextMethod to call the default initialize method
## we don't inhibit classes that extend "track" from using the general
## form of the new() function.  In the previous version, they could only
## use x and y as arguments to new, unless they wrote their own
## initialize method.

setMethod("initialize", "track", function(.Object, ...) {
    .Object <- callNextMethod()
    if(length(.Object@x) != length(.Object@y))
     stop("specified x and y of different lengths")
    .Object
  })

\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{nonStructure-class}{A non-structure S4 Class for basic types}{nonStructure.Rdash.class}
\aliasA{Math,nonStructure-method}{nonStructure-class}{Math,nonStructure.Rdash.method}
\aliasA{Math2,nonStructure-method}{nonStructure-class}{Math2,nonStructure.Rdash.method}
\aliasA{Ops,nonStructure,nonStructure-method}{nonStructure-class}{Ops,nonStructure,nonStructure.Rdash.method}
\aliasA{Ops,nonStructure,vector-method}{nonStructure-class}{Ops,nonStructure,vector.Rdash.method}
\aliasA{Ops,vector,nonStructure-method}{nonStructure-class}{Ops,vector,nonStructure.Rdash.method}
\keyword{classes}{nonStructure-class}
%
\begin{Description}\relax
 S4 classes that are defined to extend one of the basic
vector classes should contain the class
\code{\LinkA{structure}{structure.Rdash.class}} if they behave like structures; that
is, if they should retain their class behavior under math functions
or operators, so long as their length is unchanged.
On the other hand, if their class depends on the values in the
object, not just its structure, then they should lose that class
under any such transformations.  In the latter case, they should be
defined to contain \code{nonStructure}.

If neither of these strategies applies, the class likely needs some
methods of its own for \code{\LinkA{Ops}{Ops}}, \code{\LinkA{Math}{Math}}, and/or
other generic functions. What is not usually a good idea is to allow
such computations to drop down to the default, base code.  This is
inconsistent with most definitions of such classes.
\end{Description}
%
\begin{Section}{Methods}
Methods are defined for operators and math functions (groups
\code{\LinkA{Ops}{Ops}}, \code{\LinkA{Math}{Math}} and  \code{\LinkA{Math2}{Math2}}.  In
all cases the result is an ordinary vector of the appropriate type.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{structure}{structure.Rdash.class}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
setClass("NumericNotStructure", contains = c("numeric","nonStructure"))
xx <- new("NumericNotStructure", 1:10)
xx + 1 # vector
log(xx) # vector
sample(xx) # vector

\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{ObjectsWithPackage-class}{A Vector of Object Names, with associated Package Names}{ObjectsWithPackage.Rdash.class}
\keyword{classes}{ObjectsWithPackage-class}
%
\begin{Description}\relax
This class of objects is used to represent ordinary character string
object names, extended with a \code{package} slot naming the package
associated with each object.
\end{Description}
%
\begin{Section}{Objects from the Class}
The function \code{\LinkA{getGenerics}{getGenerics}} returns an object of this class.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] Object of class \code{"character"}: the
object names.
\item[\code{package}:] Object of class \code{"character"} the
package names.

\end{description}

\end{Section}
%
\begin{Section}{Extends}
Class \code{"character"}, from data part.\\{}
Class \code{"vector"}, by class \code{"character"}.
\end{Section}
%
\begin{SeeAlso}\relax
 \code{Methods} for general background. 
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{promptClass}{Generate a Shell for Documentation of a Formal Class}{promptClass}
\keyword{programming}{promptClass}
\keyword{classes}{promptClass}
%
\begin{Description}\relax
Assembles all relevant slot and method information for a class, with
minimal markup for Rd processing; no QC facilities at present.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
promptClass(clName, filename = NULL, type = "class",
            keywords = "classes", where = topenv(parent.frame()))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{clName}] a character string naming the class to be documented.
\item[\code{filename}] usually, a connection or a character string giving the
name of the file to which the documentation shell should be written.
The default corresponds to a file whose name is the topic name for
the class documentation, followed by \code{".Rd"}.  Can also be
\code{NA} (see below).
\item[\code{type}] the documentation type to be declared in the output file.
\item[\code{keywords}] the keywords to include in the shell of the
documentation.  The keyword \code{"classes"} should be one of
them.
\item[\code{where}] where to look for the definition of the class and of
methods that use it.


\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The class definition is found on the search list.  Using that
definition, information about classes extended and slots is
determined.

In addition, the currently available generics with methods for this
class are found (using \code{\LinkA{getGenerics}{getGenerics}}).  Note that these
methods need not be in the same environment as the class definition; in
particular, this part of the output may depend on which packages are
currently in the search list.

As with other prompt-style functions, unless \code{filename} is
\code{NA}, the documentation shell is written to a file, and a message
about this is given.  The file will need editing to give information
about the \emph{meaning} of the class.  The output of
\code{promptClass} can only contain information from the metadata
about the formal definition and how it is used.

If \code{filename} is \code{NA}, a list-style representation of the
documentation shell is created and returned.  Writing the shell to a
file amounts to \code{cat(unlist(x), file = filename, sep = "\bsl{}n")},
where \code{x} is the list-style representation.
\end{Details}
%
\begin{Value}
If \code{filename} is \code{NA}, a list-style representation of the
documentation shell.  Otherwise, the name of the file written to is
returned invisibly.
\end{Value}
%
\begin{Author}\relax
VJ Carey \email{stvjc@channing.harvard.edu} and John Chambers
\end{Author}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.) 
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{prompt}{prompt}} for documentation of functions,
\code{\LinkA{promptMethods}{promptMethods}} for documentation of method definitions.

For processing of the edited documentation, either use
\code{R CMD \LinkA{Rdconv}{Rdconv}},
or include the edited file in the \file{man} subdirectory of a
package.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

## Not run: > promptClass("track")
A shell of class documentation has been written to the
file "track-class.Rd".

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{promptMethods}{Generate a Shell for Documentation of Formal Methods}{promptMethods}
\keyword{programming}{promptMethods}
\keyword{methods}{promptMethods}
%
\begin{Description}\relax
Generates a shell of documentation for the methods of a generic
function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
promptMethods(f, filename = NULL, methods)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}] a character string naming the generic function whose methods
are to be documented.
\item[\code{filename}] usually, a connection or a character string giving the
name of the file to which the documentation shell should be written.
The default corresponds to the coded topic name for these methods
(currently, \code{f} followed by \code{"-methods.Rd"}).  Can also be
\code{FALSE} or \code{NA} (see below).
\item[\code{methods}] Optional methods list object giving the methods to be
documented.  By default, the first methods object for this generic
is used (for example, if the current global environment has some
methods for \code{f}, these would be documented).

If this argument is supplied, it is likely to be
\code{getMethods(f, where)}, with \code{where} some package
containing methods for \code{f}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
If \code{filename} is \code{FALSE}, the text created is returned,
presumably to be inserted some other documentation file, such as the
documentation of the generic function itself (see
\code{\LinkA{prompt}{prompt}}). 

If \code{filename} is \code{NA}, a list-style representation of the
documentation shell is created and returned.  Writing the shell to a
file amounts to \code{cat(unlist(x), file = filename, sep = "\bsl{}n")},
where \code{x} is the list-style representation.

Otherwise, the documentation shell is written to the file specified by
\code{filename}.
\end{Details}
%
\begin{Value}
If \code{filename} is \code{FALSE}, the text generated;
if \code{filename} is \code{NA}, a list-style representation of the
documentation shell.
Otherwise, the name of the file written to is returned invisibly.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{prompt}{prompt}} and
\code{\LinkA{promptClass}{promptClass}}
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{representation}{Construct a Representation or a Prototype for a Class Definition}{representation}
\aliasA{prototype}{representation}{prototype}
\keyword{programming}{representation}
\keyword{classes}{representation}
%
\begin{Description}\relax
In calls to
\code{\LinkA{setClass}{setClass}}, these two functions construct,
respectively, the \code{representation} and \code{prototype}
arguments.  They do various checks and handle special cases.  You're
encouraged to use them when defining classes that, for
example, extend other classes as a data part or have multiple
superclasses, or that combine extending a class and slots.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
representation(...)
prototype(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] 
The call to representation takes arguments that are single character
strings.  Unnamed arguments are classes that a newly defined class
extends; named arguments name the explicit slots in the new class,
and specify what class each slot should have.

In the call to \code{prototype}, if an unnamed argument is
supplied, it unconditionally forms the basis for the prototype
object.  Remaining arguments are taken to correspond to slots of
this object.  It is an error to supply more than one unnamed argument.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The \code{representation} function applies tests for the validity of
the arguments.  Each must specify the name of a class.

The classes named don't have to exist when \code{representation} is
called, but if they do, then the function will check for any duplicate
slot names introduced by each of the inherited classes.

The arguments to \code{prototype} are usually named initial values
for slots, plus an optional first argument that gives the object
itself.  The unnamed argument is typically useful if there is a data
part to the definition (see the examples below).
\end{Details}
%
\begin{Value}
The value pf \code{representation}  is just the list of arguments, after these have been checked
for validity.

The value of \code{prototype} is the object to be used as the
prototype.  Slots will have been set consistently with the
arguments, but the construction does \emph{not} use the class
definition to test validity of the contents (it hardly can, since
the prototype object is usually supplied to create the definition).
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
 \code{\LinkA{setClass}{setClass}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## representation for a new class with a directly define slot "smooth"
## which should be a "numeric" object, and extending class "track"
representation("track", smooth ="numeric")


setClass("Character",representation("character"))
setClass("TypedCharacter",representation("Character",type="character"),
          prototype(character(0),type="plain"))
ttt <- new("TypedCharacter", "foo", type = "character")


setClass("num1", representation(comment = "character"),
         contains = "numeric",
         prototype = prototype(pi, comment = "Start with pi"))



\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{S3Part}{S3-style Objects and S4-class Objects}{S3Part}
\aliasA{coerce,ANY,S3-method}{S3Part}{coerce,ANY,S3.Rdash.method}
\aliasA{coerce,ANY,S4-method}{S3Part}{coerce,ANY,S4.Rdash.method}
\aliasA{coerce,oldClass,S3-method}{S3Part}{coerce,oldClass,S3.Rdash.method}
\aliasA{isXS3Class}{S3Part}{isXS3Class}
\aliasA{S3}{S3Part}{S3}
\aliasA{S3-class}{S3Part}{S3.Rdash.class}
\aliasA{S3Class}{S3Part}{S3Class}
\aliasA{S3Class<\Rdash}{S3Part}{S3Class<.Rdash.}
\aliasA{S3Part<\Rdash}{S3Part}{S3Part<.Rdash.}
\aliasA{S4}{S3Part}{S4}
\aliasA{slotsFromS3}{S3Part}{slotsFromS3}
\keyword{programming}{S3Part}
\keyword{classes}{S3Part}
%
\begin{Description}\relax
Old-style (S3) classes may be registered as S4 classes (by calling
\code{\LinkA{setOldClass}{setOldClass}}, and many have been.  These classes can
then be contained in (that is, superclasses of) regular S4 classes, allowing formal methods
and slots to be added to the S3 behavior.  The function
\code{S3Part} extracts or replaces 
the S3 part of such an object.
\code{S3Class} extracts or
replaces the S3-style class.  \code{S3Class} also applies to object
from an S4 class with \code{S3methods=TRUE} in the call to \code{\LinkA{setClass}{setClass}}.

See the details below.
Also discussed are S3 <-> S4 coercion; see the section
``S3 and S4 objects''
\end{Description}
%
\begin{Usage}
\begin{verbatim}

S3Part(object, strictS3 = FALSE, S3Class)

S3Part(object, strictS3 = FALSE, needClass = ) <- value

S3Class(object)

S3Class(object) <-  value

isXS3Class(classDef)

slotsFromS3(object)

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}

\item[\code{object}]  An object from some class that extends a registered
S3 class,
usually because the class has as
one of its superclasses an S3 class registered by a call to
\code{\LinkA{setOldClass}{setOldClass}}, or from a class that extends a basic
vector, matrix or array object type.  See the details.

For most of the functions, an S3 object can also be supplied,
with the interpretation that it is its own S3 part.

\item[\code{strictS3}]   If \code{TRUE}, the value returned by
\code{S3Part} will be an S3 object, with all the S4 slots
removed.  Otherwise, an S4 object will always
be returned; for example, from the S4 class created by
\code{\LinkA{setOldClass}{setOldClass}} as a proxy for an S3 class, rather than
the underlying S3 object.

\item[\code{S3Class}]  The character vector to be stored as the S3 class
slot in the object.  Usually, and by default, retains
the slot from \code{object}.


\item[\code{needClass}] Require that the replacement value be this class or a
subclass of it.


\item[\code{value}]  For \code{S3Part<-}, the replacement value for the S3 part of the object.
This does \emph{not} need to be an S4 object; in fact, the
usual way to create objects from these classes is by giving an
S3 object of the right class as an argument to
\code{\LinkA{new}{new}}.

For \code{S3Class<-}, the character vector that will be used as
a proxy for \code{class(x)} in S3 method dispatch.  This
replacement function can be used to control S3 per-object method
selection.



\item[\code{classDef}]  A class definition object, as returned by \code{\LinkA{getClass}{getClass}}.



\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Classes that register S3 classes by a call to
\code{\LinkA{setOldClass}{setOldClass}} have slot \code{".S3Class"} to hold
the corresponding S3 vector of class strings.
The prototype of such
a class has the value for this slot determined  by the argument to
\code{\LinkA{setOldClass}{setOldClass}}.
Other S4 classes will have the same slot if the argument
\code{S3methods = TRUE} is supplied to \code{\LinkA{setClass}{setClass}}; in
this case, the slot is set to the S4 inheritance of the class.

New S4 classes that extend (contain) such
classes also have the same slot, and by default the prototype has
the value determined  by the \code{contains=} argument to
\code{\LinkA{setClass}{setClass}}.
Individual objects from the S4 class may
have 
an S3 class corresponding to the value in the prototype or to an
(S3) subclass of that value.  See the examples below.

\code{S3Part()}  with \code{strictS3 = TRUE} constructs the underlying S3 object by eliminating
all the formally defined slots and turning off the S4 bit of the
object.  With  \code{strictS3 = FALSE} the object returned is from
the corresponding S4 class.  For consistency and generality,
\code{S3Part()} works also for classes that extend the basic vector,
matrix and array classes.  Since \R{} is somewhat arbitrary about what
it treats as an S3 class (\code{"ts"} is, but \code{"matrix"} is
not), \code{S3Part()} tries to return an S3 (that is, non-S4) object
whenever the S4 class has a suitable superclass, of either S3 or
basic object type.

One general application that relies on this generality is to use
\code{S3Part()} to get a superclass object that is guaranteed not to
be an S4 object.  If you are calling some function that checks for
S4 objects, you need to be careful not to end up in a closed loop
(\code{fooS4} calls \code{fooS3}, which checks for an S4 object and
calls \code{fooS4} again, maybe indirectly).  Using \code{S3Part()}
with \code{strictS3 = TRUE} is a mechanism to avoid such loops.


Because the contents of S3 class objects have no definition or
guarantee, the computations involving S3 parts  do
\emph{not} check for slot validity.  Slots are implemented
internally in \R{} as attributes, which are copied when present in the
S3 part.  Grave problems can occur if an S4 class
extending an S3 class uses the name of an S3 attribute as the name
of an S4 slot, and S3 code sets the attribute to an object from an
invalid class according to the S4 definition.

Frequently, \code{S3Part} can and should be avoided by simply
coercing objects to the desired class; methods are automatically
defined to deal correctly with the slots when \code{\LinkA{as}{as}} is
called to extract or replace superclass objects.

The function \code{slotsFromS3()} is a generic function used
internally to access the slots associated with the S3 part of the
object.  Methods for this function are created automatically when
\code{\LinkA{setOldClass}{setOldClass}} is called with the \code{S4Class}
argument.  Usually, there is only one S3 slot, containing the S3
class, but the \code{S4Class} argument may provide additional slots,
in the case that the S3 class has some guaranteed attributes that
can be used as formal S4 slots.  See the corresponding section in
the documentation of \code{\LinkA{setOldClass}{setOldClass}}.
\end{Details}
%
\begin{Value}

\code{S3Part}:  Returns or sets  the S3 information
(and possibly some S4 slots as well, depending on arguments
\code{S3Class} and \code{keepSlots}).  See the discussion of
argument \code{strict} above.  If it is \code{TRUE} the value
returned is an S3 object.


\code{S3Class}:  Returns or sets the character vector of S3 class(es) stored in
the object, if the class has the corresponding \code{.S3Class} slot.
Currently, the function defaults to \code{\LinkA{class}{class}} otherwise.

\code{isXS3Class}: Returns \code{TRUE} or \code{FALSE} according
to whether the class defined by \code{ClassDef}
extends S3 classes (specifically, whether it has the slot for
holding the S3 class).

\code{slotsFromS3}: returns a list of the relevant slot classes, or an
empty list for any other object.
\end{Value}
%
\begin{Section}{S3 and S4 Objects: Conversion Mechanisms}

Objects in \R{} have an internal bit that indicates whether or not to
treat the object as coming from an S4 class.  This bit is tested by
\code{\LinkA{isS4}{isS4}} and can be set on or off by \code{\LinkA{asS4}{asS4}}.
The latter function, however, does no checking or interpretation;
you should only use it if you are very certain every detail has been
handled correctly.

As a friendlier alternative, methods have been defined for coercing
to the virtual classes \code{"S3"} and \code{"S4"}.  The expressions
\code{as(object, "S3")}  and \code{as(object, "S4")}  return S3
and S4 objects, respectively.  In addition, they attempt
to do conversions in a valid way, and also check validity when
coercing to S4.

The expression \code{as(object, "S3")} can be used in two ways.  For
objects from one of the registered S3 classes, the expression will
ensure that the class attribute is the full multi-string S3 class
implied by \code{class(object)}.  If the registered class has known
attribute/slots, these will also be provided.

Another use of  \code{as(object, "S3")}  is to take an S4 object and
turn it into an S3 object with corresponding attributes.  This is
only meaningful with S4 classes that have a data part.  If you want
to operate on the object without invoking S4 methods, this
conversion is usually the safest way.

The expression  \code{as(object, "S4")} will use the attributes in
the object to create an object from the S4 definition of
\code{class(object)}. This is a general mechanism to create
partially defined version of S4 objects via S3 computations  (not
much different from invoking \code{\LinkA{new}{new}} with corresponding
arguments, but usable in this form even if the S4 object has an
initialize method with different arguments). 
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version).

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
  \code{\LinkA{setOldClass}{setOldClass}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## two examples extending S3 class "lm", class "xlm"  directly and "ylm" indirectly
setClass("xlm", representation(eps = "numeric"), contains = "lm")
setClass("ylm", representation(header = "character"), contains = "xlm")

## lm.D9 is as computed in the example for stats::lm
y1 = new("ylm", lm.D9, header = "test", eps = .1)
xx = new("xlm", lm.D9, eps =.1)
y2 = new("ylm", xx, header = "test")
stopifnot(inherits(y2, "lm"))
stopifnot(identical(y1, y2))
stopifnot(identical(S3Part(y1, strict = TRUE), lm.D9))

## note the these classes can insert an S3 subclass of "lm" as the S3 part:
myData <- data.frame(time = 1:10, y = (1:10)^.5)
myLm <- lm(cbind(y, y^3)  ~ time, myData) # S3 class: c("mlm", "lm")
ym1 = new("ylm", myLm, header = "Example", eps = 0.)

##similar classes to "xlm" and "ylm", but extending S3 class c("mlm", "lm")
setClass("xmm", representation(eps = "numeric"), contains = "mlm")
setClass("ymm", representation(header="character"), contains = "xmm")

ym2 <- new("ymm", myLm, header = "Example2", eps = .001)

# but for class "ymm", an S3 part of class "lm" is an error:
try(new("ymm", lm.D9, header = "Example2", eps = .001))

setClass("dataFrameD", representation(date = "Date"), contains = "data.frame")
myDD <- new("dataFrameD", myData, date = Sys.Date())

## S3Part() applied to classes with a data part (.Data slot)

setClass("NumX", contains="numeric", representation(id="character"))
nn = new("NumX", 1:10, id="test")
stopifnot(identical(1:10, S3Part(nn, strict = TRUE)))
          
m1 = cbind(group, weight)
setClass("MatX", contains = "matrix", representation(date = "Date"))
mx1 = new("MatX", m1, date = Sys.Date())
stopifnot(identical(m1, S3Part(mx1, strict = TRUE)))


\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{S4groupGeneric}{Group Generic Functions}{S4groupGeneric}
\aliasA{Arith}{S4groupGeneric}{Arith}
\aliasA{Compare}{S4groupGeneric}{Compare}
\aliasA{Complex}{S4groupGeneric}{Complex}
\aliasA{GroupGenericFunctions}{S4groupGeneric}{GroupGenericFunctions}
\aliasA{Logic}{S4groupGeneric}{Logic}
\aliasA{Math}{S4groupGeneric}{Math}
\aliasA{Math2}{S4groupGeneric}{Math2}
\aliasA{Ops}{S4groupGeneric}{Ops}
\aliasA{Summary}{S4groupGeneric}{Summary}
\keyword{methods}{S4groupGeneric}
%
\begin{Description}\relax
Methods can be defined  for \emph{group
generic functions}.  Each group generic function has a number of
\emph{member} generic functions associated with it.

Methods  defined for a group generic function cause the same
method to be defined for each member of the group, but a method explicitly
defined for a  member of the group takes precedence over a
method defined, with the same signature, for the group generic.

The functions shown in this documentation page all reside in the
\pkg{methods} package, but the mechanism is available to any
programmer, by calling \code{\LinkA{setGroupGeneric}{setGroupGeneric}}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 group generics:
Arith(e1, e2)
Compare(e1, e2)
Ops(e1, e2)
Logic(e1, e2)
Math(x)
Math2(x, digits)
Summary(x, ..., na.rm = FALSE)
Complex(z)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x, z, e1, e2}] objects.
\item[\code{digits}] number of digits to be used in \code{round} or \code{signif}.
\item[\code{...}] further arguments passed to or from methods.
\item[\code{na.rm}] logical: should missing values be removed?
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Methods can be defined for the group generic functions by calls to
\code{\LinkA{setMethod}{setMethod}} in the usual way.
Note that the group generic functions
should never be called directly
-- a suitable error message will result if they are.  When metadata
for a group generic is loaded, the methods defined become methods
for the members of the group, but only if no method has been
specified directly for the member function for the same signature.
The effect is that group generic definitions are selected before
inherited methods but after directly specified methods.  For more on
method selection, see \code{\LinkA{Methods}{Methods}}.

There are also
S3 groups \code{Math}, \code{Ops}, \code{Summary} and
\code{Complex}, see \code{?\LinkA{S3groupGeneric}{S3groupGeneric}},
with no corresponding \R{} objects, but these are irrelevant for S4
group generic functions.

The members of the group defined by a particular generic can be
obtained by calling \code{\LinkA{getGroupMembers}{getGroupMembers}}. For the group
generic functions currently defined in this package the members are
as follows:
\begin{description}

\item[\code{Arith}] \code{"+"}, \code{"-"}, \code{"*"}, \code{"\textasciicircum{}"},
\code{"\%\%"}, \code{"\%/\%"}, \code{"/"}
\item[\code{Compare}] \code{"=="}, \code{">"}, \code{"<"},
\code{"!="}, \code{"<="}, \code{">="}
\item[\code{Logic}] \code{"\&"}, \code{"|"}.

\item[\code{Ops}] \code{"Arith"}, \code{"Compare"}, \code{"Logic"}
\item[\code{Math}] \code{"abs"}, \code{"sign"}, \code{"sqrt"},
\code{"ceiling"}, \code{"floor"}, \code{"trunc"},
\code{"cummax"}, \code{"cummin"}, \code{"cumprod"}, \code{"cumsum"},
\code{"log"}, \code{"log10"}, \code{"log2"}, \code{"log1p"},
\code{"acos"}, \code{"acosh"},
\code{"asin"}, \code{"asinh"}, \code{"atan"}, \code{"atanh"},
\code{"exp"}, \code{"expm1"}, \code{"cos"}, \code{"cosh"},
\code{"sin"}, \code{"sinh"}, \code{"tan"}, \code{"tanh"},
\code{"gamma"}, \code{"lgamma"}, \code{"digamma"},
\code{"trigamma"}

\item[\code{Math2}] \code{"round"}, \code{"signif"}
\item[\code{Summary}] \code{"max"}, \code{"min"}, \code{"range"},
\code{"prod"}, \code{"sum"}, \code{"any"}, \code{"all"}
\item[\code{Complex}] \code{"Arg"}, \code{"Conj"}, \code{"Im"},
\code{"Mod"}, \code{"Re"}

\end{description}

Note that \code{Ops} merely consists of three sub groups.

All the functions in these groups (other than the group generics
themselves) are basic functions in \R{}.  They are not by default S4 generic
functions, and many of them are defined as primitives.  However, you can still define
formal methods for them, both individually and via the group generics.  It all works more or less as you
might expect, admittedly via a bit of trickery in the background.
See \LinkA{Methods}{Methods} for details.

Note that two members of the \code{Math} group, \code{\LinkA{log}{log}} and
\code{\LinkA{trunc}{trunc}}, have \dots as an extra formal argument.
Since methods for \code{Math} will have only one formal argument,
you must set a specific method for these functions in order to call
them with the extra argument(s).

For further details about group generic functions see section 10.5 of
\emph{Software for Data Analysis}.

\end{Details}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version).
\end{References}
%
\begin{SeeAlso}\relax
 The function \code{\LinkA{callGeneric}{callGeneric}} is nearly always
relevant when writing a method for a group generic.  See the
examples below and in section 10.5 of \emph{Software for Data Analysis}.

See \LinkA{S3groupGeneric}{S3groupGeneric} for S3 group generics.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
setClass("testComplex", representation(zz = "complex"))
## method for whole group "Complex"
setMethod("Complex", "testComplex",
          function(z) c("groupMethod", callGeneric(z@zz)))
## exception for Arg() :
setMethod("Arg", "testComplex",
          function(z) c("ArgMethod", Arg(z@zz)))
z1 <- 1+2i
z2 <- new("testComplex", zz = z1)
stopifnot(identical(Mod(z2), c("groupMethod", Mod(z1))))
stopifnot(identical(Arg(z2), c("ArgMethod", Arg(z1))))
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{SClassExtension-class}{Class to Represent Inheritance (Extension) Relations}{SClassExtension.Rdash.class}
\keyword{classes}{SClassExtension-class}
%
\begin{Description}\relax
  An object from this class represents a single `is'
relationship; lists of these objects are used to represent all the
extensions (superclasses) and subclasses for a given class.  The
object contains information about how the relation is defined and
methods to coerce, test, and replace correspondingly. 
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects from this class are generated by \code{\LinkA{setIs}{setIs}},
from direct calls and from the \code{contains=} information in a call to \code{\LinkA{setClass}{setClass}}, and from class unions created by \code{\LinkA{setClassUnion}{setClassUnion}}.
In the last case, the information is stored in defining the \emph{subclasses} of the union class (allowing unions to contain sealed classes).
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{subClass,superClass}:] The classes being extended:
corresponding to the \code{from}, and \code{to} arguments to \code{\LinkA{setIs}{setIs}}. 
\item[\code{package}:] The package to which that class belongs. 
\item[\code{coerce}:] A function to carry out the as() computation
implied by the relation.  Note that these functions should
\emph{not} be used directly.  They only deal with the
\code{strict=TRUE} calls to the \code{\LinkA{as}{as}} function, with
the full method constructed from this mechanically. 
\item[\code{test}:] The function that would test whether the
relation holds.  Except for explicitly specified \code{test}
arguments to \code{\LinkA{setIs}{setIs}}, this function is trivial. 
\item[\code{replace}:] The method used to implement \code{as(x,
    Class) <- value}.
\item[\code{simple}:] A \code{"logical"} flag, \code{TRUE} if this
is a simple relation, either because one class is contained in the
definition of another, or because a class has been explicitly
stated to extend a virtual class.  For simple extensions, the
three methods are generated automatically.
\item[\code{by}:] If this relation has been constructed
transitively, the first intermediate class from the subclass. 
\item[\code{dataPart}:] A \code{"logical"} flag, \code{TRUE} if
the extended class is in fact the data part of the subclass.  In
this case the extended class is a basic class (i.e., a type). 
\item[\code{distance}:] The distance between the two classes,
1 for directly contained classes, plus the number of generations between otherwise.  
\end{description}

\end{Section}
%
\begin{Section}{Methods}
No methods defined with class \code{"SClassExtension"} in the
signature.
\end{Section}
%
\begin{SeeAlso}\relax
\code{\LinkA{is}{is}},
\code{\LinkA{as}{as}}, and the
\code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}} class.
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{selectSuperClasses}{Super Classes (of Specific Kinds) of a Class}{selectSuperClasses}
\aliasA{.selectSuperClasses}{selectSuperClasses}{.selectSuperClasses}
\keyword{programming}{selectSuperClasses}
\keyword{classes}{selectSuperClasses}
%
\begin{Description}\relax
Return superclasses of \code{ClassDef}, possibly only non-virtual or
direct or simple ones.

These functions are designed to be fast, and consequently only work
with the \code{contains} slot of the corresponding class definitions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
selectSuperClasses(Class, dropVirtual = FALSE, namesOnly = TRUE,
                   directOnly = TRUE, simpleOnly = directOnly,
                   where = topenv(parent.frame()))

.selectSuperClasses(ext, dropVirtual = FALSE, namesOnly = TRUE,
                    directOnly = TRUE, simpleOnly = directOnly)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}] name of the class or (more efficiently) the class
definition object (see \code{\LinkA{getClass}{getClass}}).
\item[\code{dropVirtual}] logical indicating if only non-virtual superclasses
should be returned.
\item[\code{namesOnly}] logical indicating if only a vector names instead of
a named list class-extensions should be returned.
\item[\code{directOnly}] logical indicating if only a \emph{direct} super
classes should be returned.
\item[\code{simpleOnly}] logical indicating if only simple class extensions
should be returned.
\item[\code{where}] (only used when \code{Class} is not a class definition)
environment where the class definition of \code{Class} is found.
\item[\code{ext}] for \code{.selectSuperClasses()} only, a \code{\LinkA{list}{list}}
of class extensions, typically \code{\LinkA{getClassDef}{getClassDef}(..)@contains}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a \code{\LinkA{character}{character}} vector (if \code{namesOnly} is true, as per
default) or a list of class extensions (as the \code{contains} slot in
the result of \code{\LinkA{getClass}{getClass}}).
\end{Value}
%
\begin{Note}\relax
The typical user level function is \code{selectSuperClasses()}
which calls \code{.selectSuperClasses()}; i.e., the latter should only
be used for efficiency reasons by experienced useRs.
\end{Note}
%
\begin{SeeAlso}\relax
\code{\LinkA{is}{is}}, \code{\LinkA{getClass}{getClass}}; further, the more technical
class \code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}} documentation.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
setClass("Root")
setClass("Base", contains = "Root", representation(length = "integer"))
setClass("A", contains = "Base", representation(x = "numeric"))
setClass("B", contains = "Base", representation(y = "character"))
setClass("C", contains = c("A", "B"))

extends("C")   #-->  "C"  "A" "B"  "Base" "Root"
selectSuperClasses("C") # "A" "B"
selectSuperClasses("C", direct=FALSE) # "A" "B"  "Base"  "Root"
selectSuperClasses("C", dropVirt = TRUE, direct=FALSE)# ditto w/o "Root"
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{setClass}{Create a Class Definition}{setClass}
\keyword{programming}{setClass}
\keyword{classes}{setClass}
\keyword{methods}{setClass}
%
\begin{Description}\relax
Create  a class definition, specifying the representation (the slots) and/or the classes contained in this one (the superclasses), plus other optional details.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setClass(Class, representation, prototype, contains=character(),
         validity, access, where, version, sealed, package,
         S3methods = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}] character string name for the class.
\item[\code{representation}]  a named list of the slots that the new class should have, the names giving the names of the slots and the corresponding elements being the character string names of  the corresponding classes.
Usually a call to
the \code{\LinkA{representation}{representation}} function. 

Backward compatibility and compatibility with S-Plus allows unnamed
elements for superclasses, but the recommended style is to use the
\code{contains=} argument instead.
\item[\code{prototype}]  an object providing the default
data for the slots in this class.  Usually and preferably the
result of a call to \code{\LinkA{prototype}{prototype}}. 
\item[\code{contains}]  what classes does this class extend?  (These are
called \emph{superclasses} in some languages.)  When these classes
have slots, all their slots will be contained in the new class as
well. 
\item[\code{where}]  the
environment in which to store or remove the
definition.  Defaults to the top-level environment of the calling function
(the global environment for ordinary computations, and the
environment or name space of a package in the source code for that package).

\item[\code{validity}]  if supplied, should be a validity-checking method
for objects from this class (a function that returns \code{TRUE} if
its argument is a valid object of this class and one or more strings
describing the failures otherwise).  See \code{\LinkA{validObject}{validObject}}
for details.
\item[\code{access, version}] access and version, included for
compatibility with S-Plus, but currently ignored.
\item[\code{sealed}]  if \code{TRUE}, the class definition will be sealed,
so that another call to \code{setClass} will fail on this class name.

\item[\code{package}]  an optional package name for the class.  By default
(and usually) the name of the package in which the class definition is assigned.

\item[\code{S3methods}] if \code{TRUE}, S3 methods may be written for this
class.  S3 generic functions and primitives will
dispatch an S3 method defined for this class, given an S4 object
from the class or from a subclass of it, provided no S4
method and no more 
direct S3 method is found.  Writing S3 methods for S4 classes is
somewhat deprecated (see \LinkA{Methods}{Methods}), but if you do write
them, the class should be created with this argument
\code{TRUE}, so inheritance will work.  By default, the current
implementation takes no special action, so that methods will be
dispatched for this class but \emph{not} for subclasses.  Note
that future versions may revoke this and dispatch no S3 methods
other than the default unless \code{S3methods} is \code{TRUE}.

\end{ldescription}
\end{Arguments}
%
\begin{Section}{Basic Use: Slots and Inheritance}
The two essential arguments, other than the class name are
\code{representation} and \code{contains}, defining the explicit slots
and the inheritance (superclasses). Together, these arguments define
all the information in an object from this class; that is, the names
of all the slots and the classes required for each of them.

The name of the class determines
which methods apply directly to objects from this class.  The 
inheritance information specifies which methods apply indirectly,
through inheritance.  See \LinkA{Methods}{Methods}.

The slots in a class definition will be the union of all the slots
specified directly by \code{representation} and all the slots in all
the contained classes.
There can only be one slot with a given name; specifically, the
direct and inherited slot names must be unique.
That does not, however, prevent the same class from being inherited
via more than one path.

One kind of element in the \code{contains=} argument is special, specifying one of the \R{}
object types or one of a few other special \R{} types (\code{matrix} and
\code{array}).
See the section on inheriting from object types, below.


Certain slot names are not allowed in the current implementation, as
they correspond to \LinkA{attributes}{attributes} which are treated
specially.  These are \code{class}, \code{comment}, \code{dim},
\code{dimnames}, \code{names}, \code{row.names} and \code{tsp}.
Some other slot names have special meaning; these names start with
the \code{"."} character.  To be safe, you should define all of
your own slots with names starting with an alphabetic character.
\end{Section}
%
\begin{Section}{Inheriting from Object Types}
In addition to containing other S4 classes, a class definition can
contain either an S3 class (see the next section) or a built-in R pseudo-class---one
of the \R{}
object types or one of the special \R{} pseudo-classes \code{"matrix"} and
\code{"array"}.
A class can contain at most one of the object types, directly or indirectly.
When it does, that contained class determines the ``data part''
of the class.

Objects from the new class try to inherit the built in
behavior of the contained type.
In the case of normal \R{} data types, including vectors, functions and
expressions, the implementation is relatively straightforward.
For any object \code{x} from the class,
\code{typeof(x)} will be the contained basic type; and a special
pseudo-slot, \code{.Data}, will be shown with the corresponding class.
See the \code{"numWithId"} example below.

For an object from any class that does \emph{not} contain such a type,
\code{typeof(x)} will be \code{"S4"}.

Some \R{} data types do not behave normally, in the sense that they are
non-local references or other objects that are not duplicated.
Examples include those corresponding to classes \code{"environment"}, \code{"externalptr"}, and \code{"name"}.
These can not be the types for objects with user-defined
classes (either S4 or S3) because setting an attribute overwrites the
object in all contexts.
It is possible to define a class that inherits from such types,
through an indirect mechanism that stores the inherited object in a
reserved slot.
The implementation tries to make such classes behave as if the object
had a data part of the corresponding object type.
Methods defined with the object type in the signature should work as
should core code that coerces an object to the type in an internal or
primitive calculation.
There is no guarantee, however, because C-level code may switch
directly on the object type, which in this case will be \code{"S4"}.
The cautious mechanism is to use \code{as(x, "environment")} or
something similar before doing the low-level computation.  See the
example for class \code{"stampedEnv"} below.

Also, keep in mind that the object passed to the low-level computation
will be the underlying object type, \emph{without} any of the slots
defined in the class.
To return the full information, you will usually have to define a
method that sets the data part.

Note that, in the current implementation, the interpretation of the
\code{".Data"} pseudo-slot includes all of the object types above, as
well as the special pseudo-classes \code{"matrix"} and
\code{"array"}, which \R{} treats internally as if they were object types
(they have no explicit class and \code{\LinkA{is.object}{is.object}} returns
\code{FALSE} for such objects).
Some of this implementation is still experimental, so a wise policy is
to use standard tools, such as \code{as(object, type)}, to convert to
the underlying data type, rather than the pseudo-slot, when possible.

\end{Section}
%
\begin{Section}{Inheriting from S3 Classes}
Old-style S3 classes have no formal definition.  Objects are
``from'' the class when their class attribute contains the
character string considered to be the class name.

Using such classes with formal classes and methods is necessarily a
risky business, since there are no guarantees about the content of the
objects or about consistency of inherited methods.
Given that, it is still possible to define a class that inherits from
an S3 class, providing that class has been registered as an old class
(see \code{\LinkA{setOldClass}{setOldClass}}).
The essential result is that S3 method dispatch will use the S3 class
as registered when dispatching.

Some additional options are planned, to control whether the object is
converted to an S3 class before dispatch.  In the present
implementation, it is not, which causes some S3 computations to
misbehave, since they are not seeing the S3 class explicitly.
\end{Section}
%
\begin{Section}{Classes and Packages}

Class definitions normally belong to packages (but can be defined in
the  global environment as well, by evaluating the expression on the
command line or in a file sourced from the command line).
The corresponding package name is part of the class definition; that
is, part of the \code{classRepresentation} object holding that
definition.  Thus, two classes with the same name can exist in
different packages, for most purposes.

When a class name is supplied for a slot or a superclass, a
corresponding class definition will be found, looking from the
name space or environment of the current package, assuming the call to
\code{setClass} in question appears directly in the source for the
package.  That's where it should appear, to avoid ambiguity.

In particular, if the current package has a name space then the  class
must be found in the current package itself, in the imports defined by that
name space, or in the base package.

When this rule does not identify a class uniquely (because it appears
in more than one imported package) then the \code{\LinkA{packageSlot}{packageSlot}}
of the character string name needs to be supplied with the name.
This should be a rare occurrence.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.) 
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{Classes}{Classes}} for a general discussion of classes,
\code{\LinkA{Methods}{Methods}} for an analogous discussion of methods,
\code{\LinkA{makeClassRepresentation}{makeClassRepresentation}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

## A simple class with two slots
setClass("track",
         representation(x="numeric", y="numeric"))
## A class extending the previous, adding one more slot
setClass("trackCurve",
    representation(smooth = "numeric"),
    contains = "track")
## A class similar to "trackCurve", but with different structure
## allowing matrices for the "y" and "smooth" slots
setClass("trackMultiCurve",
         representation(x="numeric", y="matrix", smooth="matrix"),
         prototype = list(x=numeric(), y=matrix(0,0,0),
                          smooth= matrix(0,0,0)))
##
## Suppose we want trackMultiCurve to be like trackCurve when there's
## only one column.
## First, the wrong way.
try(setIs("trackMultiCurve", "trackCurve",
    test = function(obj) {ncol(slot(obj, "y")) == 1}))

## Why didn't that work?  You can only override the slots "x", "y",
## and "smooth" if you provide an explicit coerce function to correct
## any inconsistencies:

setIs("trackMultiCurve", "trackCurve",
  test = function(obj) {ncol(slot(obj, "y")) == 1},
  coerce = function(obj) {
     new("trackCurve",
         x = slot(obj, "x"),
         y = as.numeric(slot(obj,"y")),
         smooth = as.numeric(slot(obj, "smooth")))
  })

## A class that extends the built-in data type "numeric"

setClass("numWithId", representation(id = "character"),
         contains = "numeric")

new("numWithId", 1:3, id = "An Example")

## inherit from reference object of type "environment"
setClass("stampedEnv", contains = "environment",
      representation(update = "POSIXct"))

e1 <- new("stampedEnv", new.env(), update = Sys.time())

setMethod("[[<-", c("stampedEnv", "character", "missing"),
   function(x, i, j, ..., value) {
       ev <- as(x, "environment")
       ev[[i]] <- value  #update the object in the environment
       x@update <- Sys.time() # and the update time
       x})

e1[["noise"]] <- rnorm(10)


\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{setClassUnion}{Classes Defined as the Union of Other Classes}{setClassUnion}
\aliasA{ClassUnionRepresentation-class}{setClassUnion}{ClassUnionRepresentation.Rdash.class}
\aliasA{isClassUnion}{setClassUnion}{isClassUnion}
\keyword{programming}{setClassUnion}
\keyword{classes}{setClassUnion}
%
\begin{Description}\relax
A class may be defined as the \emph{union} of other classes; that
is, as a virtual class defined as a superclass of several other
classes. Class unions are useful in method signatures or as slots in
other classes, when we want to allow one of several classes to be supplied.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setClassUnion(name, members, where)
isClassUnion(Class)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}]  the name for the new union class. 
\item[\code{members}]  the classes that should be members of this union.
\item[\code{where}]  where to save the new class definition; by default,
the environment of the package in which the \code{setClassUnion}
call appears, or the global environment if called outside of the
source of a package.


\item[\code{Class}]  the name or definition of a class.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The classes in \code{members} must be defined before creating the
union.  However, members can be added later on to an existing
union, as shown in the example below. Class unions can be
members of other class unions.

Class unions are the only way to create a class that is extended by
a class whose definition is sealed (for example, the
basic datatypes or other classes defined in the base or methods
package in R are sealed).  You cannot say \code{setIs("function", "other")}
unless \code{"other"} is a class union.  In general, a
\code{setIs} call of this form changes the definition of the
first class mentioned (adding \code{"other"} to the list of
superclasses contained in the definition of \code{"function"}).

Class unions get around this by not modifying the first class
definition, relying instead on storing information in the subclasses
slot of the class union.  In order for this technique to work, the
internal computations for expressions such as
\code{\LinkA{extends}{extends}(class1, class2)} work
differently for class unions than for regular classes; specifically,
they test whether any class is in common between the superclasses of
\code{class1} and the subclasses of \code{class2}.

The different behavior for class unions is made possible because the
class definition object for class unions has itself a special class,
\code{"ClassUnionRepresentation"}, an extension of class
\code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}.

\end{Details}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
## a class for either numeric or logical data
setClassUnion("maybeNumber", c("numeric", "logical"))

## use the union as the data part of another class
setClass("withId", representation("maybeNumber", id = "character"))

w1 <- new("withId", 1:10, id = "test 1")
w2 <- new("withId", sqrt(w1)%%1 < .01, id = "Perfect squares")

## add class "complex" to the union "maybeNumber"
setIs("complex", "maybeNumber")

w3 <- new("withId", complex(real = 1:10, imaginary = sqrt(1:10)))

## a class union containing the existing class  union "OptionalFunction"
setClassUnion("maybeCode",
    c("expression", "language", "OptionalFunction"))

is(quote(sqrt(1:10)), "maybeCode")  ## TRUE


\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{setGeneric}{Define a New Generic Function}{setGeneric}
\aliasA{setGroupGeneric}{setGeneric}{setGroupGeneric}
\keyword{programming}{setGeneric}
\keyword{methods}{setGeneric}
%
\begin{Description}\relax
Create a new generic function of the given name, that is, a function
that dispatches methods according to the classes of the arguments,
from among the formal methods defined for this function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setGeneric(name, def= , group=list(), valueClass=character(),
           where= , package= , signature= , useAsDefault= ,
           genericFunction= , simpleInheritanceOnly = )

setGroupGeneric(name, def= , group=list(), valueClass=character(),
                knownMembers=list(), package= , where= )
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}]  The character string name of the generic function.
The simplest (and recommended) call, \code{setGeneric(name)},
looks for a function with this name and creates a corresponding
generic function,  if the function found was not generic.

\item[\code{def}]  An optional function object, defining the generic.
Don't supply this argument if you want an existing non-generic
function to supply the arguments. Do supply it if there is
no current function of this name, or if you want the generic
function to have different arguments. In that case, the formal arguments
and default values for the generic are taken from \code{def}.  You
can also supply this argument if you want the generic function to
do something other than just dispatch methods.

Note that \code{def} is \emph{not} the default method; use argument
\code{useAsDefault} if you want to specify the default separately.

\item[\code{group}]  Optionally, a character string giving the name of the group
generic function to which this function belongs.    See
\LinkA{Methods}{Methods} for details of group generic functions in method selection.

\item[\code{valueClass}]  An optional character vector of one or more class
names.  The value returned by the generic function must
have (or extend) this class, or one of the classes; otherwise,
an error is generated.

\item[\code{package}]  The name of the package with which this function is
associated.  Usually determined automatically (as the package
containing the non-generic version if there is one, or else the
package where this generic is to be saved).

\item[\code{where}]  Where to store the resulting initial methods definition,
and possibly the generic function; by
default, stored into the top-level environment.

\item[\code{signature}] 
Optionally, the vector of names, from among the formal arguments
to the  function, that can
appear in the signature of methods for this function, in calls to
\code{\LinkA{setMethod}{setMethod}}. If \dots is one of the
formal arguments, it is treated specially. Starting with version
2.8.0 of \R{}, \dots may be signature of the generic function.
Methods will then be selected if their signature matches all the
\dots arguments.  See the documentation for topic
\LinkA{dotsMethods}{dotsMethods} for details.  In the present version, it is not
possible to mix \dots and other arguments in the signature (this
restriction may be lifted in later versions).

By default, the signature is inferred from the implicit generic
function corresponding to a  non-generic function.  If no implicit generic function has been defined,  the default is all the
formal arguments except \dots, in the order they appear in the
function definition. In the case that
\dots is the only formal argument, that is also the default signature.  To use \dots as the signature
in a function that has any other arguments, you must supply the
signature argument explicitly.  See the ``Implicit
Generic'' section below for more details.

\item[\code{useAsDefault}] 
Override the usual choice of default argument (an existing
non-generic function or no default if there is no such function).
Argument \code{useAsDefault} can be supplied,
either as a function to use for the default, or as a logical value.
\code{FALSE} says not to have a default method at all, so that an
error occurs if there is not an explicit or inherited method for a
call.
\code{TRUE} says to use the existing function as default,
unconditionally (hardly ever needed as an explicit argument).
See the section on details.

\item[\code{simpleInheritanceOnly}] 
Supply this argument as \code{TRUE} to require that methods
selected be inherited through simple inheritance only; that is,
from superclasses specified in the \code{contains=} argument to
\code{\LinkA{setClass}{setClass}}, or by simple inheritance to a class
union or other virtual class.  Generic functions should require
simple inheritance if they need to be assured that they get the
complete original object, not one that has been transformed.
Examples of functions requiring simple inheritance are
\code{\LinkA{initialize}{initialize}}, because by definition it must return
an object from the same class as its argument, and
\code{\LinkA{show}{show}}, because it claims to give a full description
of the object provided as its argument.

\item[\code{genericFunction}]  Don't use; for (possible) internal use only.


\item[\code{knownMembers}] 
(For \code{setGroupGeneric} only.)  The names of functions that are
known to be members of this group.  This information is used to
reset cached definitions of the member generics when information
about the group generic is changed.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The \code{setGeneric} function exists for its side effect: saving the
generic function to allow methods to be specified later.  It returns
\code{name}.
\end{Value}
%
\begin{Section}{Basic Use}
The \code{setGeneric} function is called to initialize a generic
function as
preparation for defining some methods for that function.

The simplest and most common situation is that \code{name} is already
an ordinary non-generic non-primitive function, and you now want to turn this
function into a generic.  In this case you will most often supply only
\code{name}, for example:

\code{setGeneric("colSums")}

There must be an existing function of this name, on some  attached package (in this case package \code{"base"}).
A generic version of this function will be created in the current package (or in the global environment if the call to \code{setGeneric()} is from an ordinary source file or is entered on the command line).
The existing function becomes the default method, and
the package slot of the new generic function is set to the location of the original function (\code{"base"} in the example).  It's an important feature that the same generic function definition is created each time, depending in the example only on the definition of \code{print} and where it is found.
The \code{signature} of the generic function, defining which of the formal arguments can be used in specifying methods, is set by default to all the formal arguments except \dots.

Note that calling \code{setGeneric()} in this form is not strictly necessary before calling \code{setMethod()} for the same function.  If the function specified in the call to \code{setMethod} is not generic, \code{setMethod} will execute the call to \code{setGeneric} itself.  Declaring explicitly that you want the function to be generic can be considered better programming style; the only difference in the result, however, is that not doing so produces a message noting the creation of the generic function.

You cannot (and never need to) create an explicit generic version of the
primitive functions in the base package.  Those which can be treated
as generic functions have methods selected and
dispatched from the internal C code, to satisfy concerns for  efficiency, and the others cannot be made
generic.  See the section on Primitive Functions below.

The description above is the effect when the package that owns the non-generic function has not created an implicit generic version.  Otherwise, it is this implicit generic function that is used. See the section on Implicit Generic Functions below.  Either way, the essential result is that the \emph{same} version of the  generic function will be created each time.

The second common use of \code{setGeneric()}  is to create a new generic
function, unrelated to any existing function, and frequently having no default method.  In this case, you
need to supply a skeleton of the function definition, to define the
arguments for the function.  The body of a generic function is
usually a standard form, \code{standardGeneric(name)} where
\code{name} is the quoted name of the generic function.
When calling \code{setGeneric} in this form, you would normally
supply the \code{def} argument as a function of this form.  See the second and third examples below.

The \code{useAsDefault} argument controls the default method for the new generic.
If not
told otherwise, \code{setGeneric} will try to find a non-generic
version of the function to use as a default.
So, if you do have a suitable default method, it is often simpler to first set this up as a non-generic function, and then use the one-argument call to \code{setGeneric} at the beginning of this section.   See the first example in the Examples section below.

If you \emph{don't} want the existing function to be taken as default, supply the argument \code{useAsDefault}.  That argument
can be the function you want to be the default method, or
\code{FALSE} to force no default (i.e., to cause an error if
there is no direct or inherited method selected for a call to the function).
\end{Section}
%
\begin{Section}{Details}
If you want to change the behavior of an existing function (typically, one in another package) when you create a generic version, you must supply arguments to \code{setGeneric} correspondingly.
Whatever changes are made, the new generic function will be assigned with a package slot set to the \emph{current} package, not the one in which the non-generic version of the function is found.
This step is required because the version you are creating is no longer the same as that implied by the function in the other package.
A message will be printed to indicate that this has taken place and noting one of the differences between the two functions.


The body of a generic function usually does nothing
except for dispatching methods by a call to \code{standardGeneric}.
Under some circumstances you might just want to do some additional
computation in the generic function itself.  As long as your
function eventually calls \code{standardGeneric} that is permissible
(though perhaps not a good idea, in that it may make the behavior of
your function less easy to understand).  If your explicit
definition of the generic function
does \emph{not} call \code{standardGeneric} you are in trouble,
because none of the methods for the function will ever be
dispatched.

By default, the generic function can return any object.  If
\code{valueClass} is supplied, it should be a vector of class names;
the value returned by a method is then required to satisfy
\code{is(object, Class)} for one of the specified classes.  An empty
(i.e., zero length) vector of classes means anything is allowed.  Note
that more complicated requirements on the result can be specified
explicitly, by defining a non-standard generic function.

The \code{setGroupGeneric} function behaves like \code{setGeneric}
except that it constructs a group generic function, differing in two
ways from an ordinary generic function.  First, this function cannot
be called directly, and the body of the function created will contain
a stop call with this information.  Second, the group generic
function contains information about the known members of the group,
used to keep the members up to date when the group definition
changes, through changes in the search list or direct specification
of methods, etc.
\end{Section}
%
\begin{Section}{Implicit Generic Functions}

Saying that a non-generic function ``is converted to a generic''
is more precisely state that the function is converted to the
corresponding \emph{implicit} generic function.
If no special action has been taken, any function corresponds
implicitly to a generic function with the same arguments, in which
all arguments
other than \dots can be used.  The signature of this generic
function is the vector of formal arguments, in order, except for
\dots.

The source code for a package can define an implicit generic function
version of any function in that package (see \LinkA{implicitGeneric}{implicitGeneric}
for the mechanism).  You can not, generally, define an implicit
generic function in someone else's package. The usual reason for
defining an implicit generic is to prevent certain arguments from
appearing in the signature, which you must do if you want the
arguments to be used literally or if you want to enforce lazy
evaluation for any reason.  An implicit generic can also contain some
methods that you want to be predefined; in fact, the implicit generic
can be any generic version of the non-generic function.  The implicit
generic mechanism can also be used to prohibit a generic version (see \code{\LinkA{prohibitGeneric}{prohibitGeneric}}).

Whether defined or inferred automatically, the implicit generic will
be compared with the generic function that \code{setGeneric}
creates, when the implicit generic is in another package.  If the two
functions are identical, then the \code{package} slot of the created
generic will have the name of the package containing the implicit
generic.  Otherwise, the slot will be the name of the package in which
the generic is assigned.

The purpose of this rule is to ensure that all methods defined for a
particular combination of generic function and package names
correspond to a single, consistent version of the generic
function.  Calling \code{setGeneric} with only \code{name} and
possibly \code{package} as arguments guarantees getting the implicit
generic version, if one exists.

Including any of the other arguments can force a new, local version of
the generic function.  If you don't want to create a new version,
don't use the extra arguments.
\end{Section}
%
\begin{Section}{Generic Functions and Primitive Functions}
A number of the basic \R{} functions are specially implemented as
primitive functions, to be evaluated directly in the underlying C
code rather than by evaluating an \R{} language definition.  Most have
implicit generics (see \code{\LinkA{implicitGeneric}{implicitGeneric}}), and become
generic as soon as methods (including group methods) are defined on
them.  Others cannot be made generic.

Even when methods are defined for such functions, the generic
version is not visible on the search list, in order that the C
version continues to be called.  Method selection will be initiated
in the C code.  Note, however, that the result is to restrict
methods for primitive functions to signatures in which at least one
of the classes in the signature is a formal S4 class.

To see the generic version of a primitive function, use
\code{\LinkA{getGeneric}{getGeneric}(name)}.  The function
\code{\LinkA{isGeneric}{isGeneric}} will tell you whether methods are defined
for the function in the current session.

Note that S4 methods can only be set on those primitives which are
`\LinkA{internal generic}{internal generic}', plus \code{\%*\%}.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{Methods}{Methods}} and the links there for a general discussion,
\code{\LinkA{dotsMethods}{dotsMethods}} for methods that dispatch on
``\dots'', and \code{\LinkA{setMethod}{setMethod}} for method definitions.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}


## create a new generic function, with a default method
props <- function(object) attributes(object)
setGeneric("props")

## A new generic function with no default method
setGeneric("increment",
  function(object, step, ...)
    standardGeneric("increment")
)


###   A non-standard generic function.  It insists that the methods
###   return a non-empty character vector (a stronger requirement than
###    valueClass = "character" in the call to setGeneric)

setGeneric("authorNames",
    function(text) {
      value <- standardGeneric("authorNames")
      if(!(is(value, "character") && any(nchar(value)>0)))
        stop("authorNames methods must return non-empty strings")
      value
      })



## An example of group generic methods, using the class
## "track"; see the documentation of setClass for its definition

## define a method for the Arith group

setMethod("Arith", c("track", "numeric"),
 function(e1, e2) {
  e1@y <- callGeneric(e1@y , e2)
  e1
})

setMethod("Arith", c("numeric", "track"),
 function(e1, e2) {
  e2@y <- callGeneric(e1, e2@y)
  e2
})

## now arithmetic operators  will dispatch methods:

t1 <- new("track", x=1:10, y=sort(stats::rnorm(10)))

t1 - 100
1/t1


\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{setMethod}{Create and Save a Method}{setMethod}
\aliasA{removeMethod}{setMethod}{removeMethod}
\keyword{programming}{setMethod}
\keyword{classes}{setMethod}
\keyword{methods}{setMethod}
%
\begin{Description}\relax
Create and save a formal method for a given function and list of classes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setMethod(f, signature=character(), definition,
          where = topenv(parent.frame()),
          valueClass = NULL, sealed = FALSE)

removeMethod(f, signature, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}]  A generic function or the character-string name of the function. 
\item[\code{signature}]  A match of formal argument names for \code{f} with
the character-string names of corresponding classes.  See the
details below; however, if the signature is not trivial, you should use \code{\LinkA{method.skeleton}{method.skeleton}} to generate a valid call to \code{setMethod}.
\item[\code{definition}]  A function definition, which will become the method
called when the arguments in a call to \code{f} match the
classes in \code{signature}, directly or through inheritance. 
\item[\code{where}] the environment in which to store the definition of the
method.
For \code{setMethod}, it is recommended to omit this argument and to include the call in source code that is evaluated at the top level; that is, either in an R session by something equivalent to a call to \code{\LinkA{source}{source}}, or as part of the R source code for a package.

For \code{removeMethod}, the default is the location of the (first)
instance of the method for this signature.
\item[\code{valueClass}]  Obsolete and unused, but see the same argument for \code{\LinkA{setGeneric}{setGeneric}}. 
\item[\code{sealed}]  If \code{TRUE}, the method so defined cannot be
redefined by another call to \code{setMethod} (although it can
be removed and then re-assigned).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The call to \code{setMethod} stores the supplied method definition  in
the metadata table for this generic function in the environment,
typically the global environment or the name space of a package.
In the case of a package, the table object becomes part of the name space or environment of the
package.
When the package is loaded into a later session, the
methods will be merged into the table of methods in the corresponding
generic function object.

Generic functions are referenced by the combination of the function name and
the package name;
for example, the function \code{"show"} from the package
\code{"methods"}.
Metadata for methods is identified by the two strings; in particular, the
generic function object itself has slots containing its name and its
package name.
The package name of a generic is set according to the package
from which it originally comes; in particular, and frequently, the
package where a non-generic version of the function originated.
For example, generic functions for all the functions in package \pkg{base} will
have \code{"base"} as the package name, although none of them is an
S4 generic on that package.
These include most of the base functions that are primitives, rather than
true functions; see the section on primitive functions in the
documentation for \code{\LinkA{setGeneric}{setGeneric}} for details.

Multiple packages can have methods for the same generic function; that
is, for the same combination of generic function name and package
name.
Even though the methods are stored in separate tables in separate
environments, loading the corresponding packages adds the methods to
the table in the generic function itself, for the duration of the session.

The class
names in the signature can be any formal class, including basic
classes such as \code{"numeric"}, \code{"character"}, and
\code{"matrix"}.  Two additional special class names can appear:
\code{"ANY"}, meaning that this argument can have any class at all;
and \code{"missing"}, meaning that this argument \emph{must not}
appear in the call in order to match this signature.  Don't confuse
these two:  if an argument isn't mentioned in a signature, it
corresponds implicitly to class \code{"ANY"}, not to
\code{"missing"}.  See the example below.  Old-style (`S3')
classes can also be used, if you need compatibility with these, but
you should definitely declare these classes by calling
\code{\LinkA{setOldClass}{setOldClass}} if you want S3-style inheritance to work.


Method definitions can
have default expressions for arguments, but a current limitation is
that the generic function must have \emph{some} default expression for the
same argument in order for the method's defaults to be used.
If so, and if the corresponding argument is
missing in the call to the generic function, the default expression
in the method is used.  If the method definition has no default for
the argument, then the expression supplied in the definition of the
generic function itself is used, but note that this expression will
be evaluated using the enclosing environment of the method, not of
the generic function.
Note also that specifying class \code{"missing"} in the signature
does not require any default expressions, and method selection does
not evaluate default expressions.
All actual (non-missing) arguments in the signature of the
generic function will be evaluated when a method is selected---when
the call to \code{standardGeneric(f)} occurs.

It is possible to have some differences between the
formal arguments to a method supplied to \code{setMethod} and those
of the generic. Roughly, if the generic has \dots as one of its
arguments, then the method may have extra formal arguments, which
will be matched from the arguments matching \dots in the call to
\code{f}.  (What actually happens is that a local function is
created inside the method, with the modified formal arguments, and the method
is re-defined to call that local function.)

Method dispatch tries to match the class of the actual arguments in a
call to the available methods collected for \code{f}.  If there is a
method defined for the exact same classes as in this call, that
method is used.  Otherwise, all possible signatures are considered
corresponding to the actual classes or to superclasses of the actual
classes (including \code{"ANY"}).
The method having the least distance from the actual classes is
chosen; if more than one method has minimal distance, one is chosen
(the lexicographically first in terms of superclasses) but a warning
is issued.
All inherited methods chosen are stored in another table, so that
the inheritance calculations only need to be done once per session
per sequence of actual classes.
See
\LinkA{Methods}{Methods} for more details.

The function \code{removeMethod} removes the specified method from the
metadata table in the corresponding environment.
It's not a function that is used much, since one normally wants to
redefine a method rather than leave no definition.

\end{Details}
%
\begin{Value}
These functions exist for their side-effect, in setting or removing a
method in the object defining methods for the specified generic.

The value returned by \code{removeMethod} is \code{TRUE} if a method
was found to be removed.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax

\code{\LinkA{method.skeleton}{method.skeleton}}, which is the recommended way to generate a skeleton of the call to \code{setMethod}, with the correct formal arguments and other details.

\LinkA{Methods}{Methods} and the links there for a general discussion, \code{\LinkA{dotsMethods}{dotsMethods}} for methods that dispatch on
``\dots'', and \code{\LinkA{setGeneric}{setGeneric}} for generic functions.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}


require(graphics)
## methods for plotting track objects (see the example for \link{setClass})
##
## First, with only one object as argument:
setMethod("plot", signature(x="track", y="missing"),
  function(x,  y, ...) plot(slot(x, "x"), slot(x, "y"), ...)
)
## Second, plot the data from the track on the y-axis against anything
## as the x data.
setMethod("plot", signature(y = "track"),
 function(x, y, ...) plot(x, slot(y, "y"), ...)
)
## and similarly with the track on the x-axis (using the short form of
## specification for signatures)
setMethod("plot", "track",
 function(x, y, ...) plot(slot(x, "y"), y,  ...)
)
t1 <- new("track", x=1:20, y=(1:20)^2)
tc1 <- new("trackCurve", t1)
slot(tc1, "smooth") <- smooth.spline(slot(tc1, "x"), slot(tc1, "y"))$y #$
plot(t1)
plot(qnorm(ppoints(20)), t1)
## An example of inherited methods, and of conforming method arguments
## (note the dotCurve argument in the method, which will be pulled out
## of ... in the generic.
setMethod("plot", c("trackCurve", "missing"),
function(x, y, dotCurve = FALSE, ...) {
  plot(as(x, "track"))
  if(length(slot(x, "smooth") > 0))
    lines(slot(x, "x"), slot(x, "smooth"),
         lty = if(dotCurve) 2 else 1)
  }
)
## the plot of tc1 alone has an added curve; other uses of tc1
## are treated as if it were a "track" object.
plot(tc1, dotCurve = TRUE)
plot(qnorm(ppoints(20)), tc1)

## defining methods for a special function.
## Although "[" and "length" are not ordinary functions
## methods can be defined for them.
setMethod("[", "track",
  function(x, i, j, ..., drop) {
    x@x <- x@x[i]; x@y <- x@y[i]
    x
  })
plot(t1[1:15])

setMethod("length", "track", function(x)length(x@y))
length(t1)

## methods can be defined for missing arguments as well
setGeneric("summary") ## make the function into a generic

## A method for summary()
## The method definition can include the arguments, but
## if they're omitted, class "missing" is assumed.

setMethod("summary", "missing", function() "<No Object>")


\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{setOldClass}{Register Old-Style (S3) Classes and Inheritance}{setOldClass}
\aliasA{.OldClassesList}{setOldClass}{.OldClassesList}
\aliasA{.setOldIs}{setOldClass}{.setOldIs}
\aliasA{anova-class}{setOldClass}{anova.Rdash.class}
\aliasA{anova.glm-class}{setOldClass}{anova.glm.Rdash.class}
\aliasA{anova.glm.null-class}{setOldClass}{anova.glm.null.Rdash.class}
\aliasA{aov-class}{setOldClass}{aov.Rdash.class}
\aliasA{data.frame-class}{setOldClass}{data.frame.Rdash.class}
\aliasA{data.frameRowLabels-class}{setOldClass}{data.frameRowLabels.Rdash.class}
\aliasA{Date-class}{setOldClass}{Date.Rdash.class}
\aliasA{density-class}{setOldClass}{density.Rdash.class}
\aliasA{dump.frames-class}{setOldClass}{dump.frames.Rdash.class}
\aliasA{factor-class}{setOldClass}{factor.Rdash.class}
\aliasA{formula-class}{setOldClass}{formula.Rdash.class}
\aliasA{glm-class}{setOldClass}{glm.Rdash.class}
\aliasA{glm.null-class}{setOldClass}{glm.null.Rdash.class}
\aliasA{hsearch-class}{setOldClass}{hsearch.Rdash.class}
\aliasA{initialize,data.frame-method}{setOldClass}{initialize,data.frame.Rdash.method}
\aliasA{initialize,factor-method}{setOldClass}{initialize,factor.Rdash.method}
\aliasA{initialize,ordered-method}{setOldClass}{initialize,ordered.Rdash.method}
\aliasA{initialize,summary.table-method}{setOldClass}{initialize,summary.table.Rdash.method}
\aliasA{initialize,table-method}{setOldClass}{initialize,table.Rdash.method}
\aliasA{integrate-class}{setOldClass}{integrate.Rdash.class}
\aliasA{libraryIQR-class}{setOldClass}{libraryIQR.Rdash.class}
\aliasA{lm-class}{setOldClass}{lm.Rdash.class}
\aliasA{logLik-class}{setOldClass}{logLik.Rdash.class}
\aliasA{maov-class}{setOldClass}{maov.Rdash.class}
\aliasA{mlm-class}{setOldClass}{mlm.Rdash.class}
\aliasA{mtable-class}{setOldClass}{mtable.Rdash.class}
\aliasA{mts-class}{setOldClass}{mts.Rdash.class}
\aliasA{oldClass-class}{setOldClass}{oldClass.Rdash.class}
\aliasA{ordered-class}{setOldClass}{ordered.Rdash.class}
\aliasA{packageInfo-class}{setOldClass}{packageInfo.Rdash.class}
\aliasA{packageIQR-class}{setOldClass}{packageIQR.Rdash.class}
\aliasA{POSIXct-class}{setOldClass}{POSIXct.Rdash.class}
\aliasA{POSIXlt-class}{setOldClass}{POSIXlt.Rdash.class}
\aliasA{POSIXt-class}{setOldClass}{POSIXt.Rdash.class}
\aliasA{recordedplot-class}{setOldClass}{recordedplot.Rdash.class}
\aliasA{rle-class}{setOldClass}{rle.Rdash.class}
\aliasA{socket-class}{setOldClass}{socket.Rdash.class}
\aliasA{summary.table-class}{setOldClass}{summary.table.Rdash.class}
\aliasA{table-class}{setOldClass}{table.Rdash.class}
\keyword{programming}{setOldClass}
\keyword{methods}{setOldClass}
%
\begin{Description}\relax
Register an old-style (a.k.a. `S3') class as a formally defined
class. The \code{Classes} argument is the character vector used as the
\code{class} attribute; in particular, if there is more than one
string,  old-style class inheritance is mimicked.  Registering via
\code{setOldClass} allows S3 classes to appear  in method
signatures, as a slot in an S4 class, or as a superclass of an S4 class.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setOldClass(Classes, prototype, where, test = FALSE, S4Class)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Classes}] 
A character vector, giving the names for S3
classes, as they would appear on the right side of an assignment of
the \code{class} attribute in S3 computations.

In addition to S3 classes, an object type or other valid data part
can be specified, if the S3 class is known to require its data to
be of that form.

\item[\code{prototype}] 
An optional object to use as the prototype.  This should be provided
as the default S3 object for the class.  If omitted, the S4 class
created to register the S3 class is \code{VIRTUAL}.  See the
details.

\item[\code{where}] 
Where to store the class definitions, the global or top-level
environment by default.  (When either function is called in the
source for a package, the class definitions will be included in the
package's environment by default.)

\item[\code{test}] flag, if \code{TRUE}, arrange to test inheritance 
explicitly for each object, needed if the S3 class can have a
different set of class strings, with the same first string.
This is a different mechanism in implementation and should be
specified separately for each pair of classes that have an
optional inheritance.
See the details below.

\item[\code{S4Class}]  optionally, the class definition or the class name
of an S4 class.  The new class will have all the slots and other
properties of this class, plus its S3 inheritance as defined by
the \code{Classses} argument.  Arguments \code{prototype} and
\code{test} must not be supplied in this case.  See the section
on ``S3 classes with known attributes'' below.


\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Each of the names will be defined as an S4 class, extending the
remaining classes in \code{Classes}, and the class \code{oldClass},
which is the `root' of all old-style classes. S3 classes have
no formal definition, and therefore no formally defined slots. If a
\code{prototype} argument is supplied in the call to
\code{setOldClass()}, objects from the class can be generated, by a
call to \code{\LinkA{new}{new}}; however, this usually not as relevant as
generating objects from subclasses (see the section on extending S3
classes below).   If  a prototype is not provided,
the class will be created as a virtual S4
class.
The main disadvantage is that the prototype object in an S4 class that
uses this class as a slot will have a \code{NULL} object in that slot,
which can sometimes lead to confusion.

Beginning with version 2.8.0 of \R{}, support is provided for using a
(registered) S3 class as a super class of a new S4 class.  See the
section on extending S3 classes below, and the examples.

See \LinkA{Methods}{Methods} for the details of method dispatch and
inheritance.

Some S3 classes cannot be represented as an ordinary combination of S4
classes and superclasses, because objects from the S3 class can have a
variable set of strings in the class. It is still possible to register
such classes as S4 classes, but now the inheritance has to be verified
for each object, and you must call \code{setOldClass} with argument
\code{test=TRUE} once for each superclass.

For example, ordered factors \emph{always} have the S3
class \code{c("ordered", "factor")}.  This is proper behavior, and
maps simply into two S4 classes, with \code{"ordered"} extending
\code{"factor"}.

But objects whose class attribute has \code{"POSIXt"} as the first
string may have either (or neither) of \code{"POSIXct"} or
\code{"POSIXlt"} as the second string.  This behavior can be mapped
into S4 classes but now to evaluate \code{is(x, "POSIXlt")}, for
example, requires checking the S3 class attribute on each object.
Supplying the \code{test=TRUE} argument to \code{setOldClass} causes
an explicit test to be included in the class definitions.  It's
never wrong to have this test, but since it adds significant
overhead to methods defined for the inherited classes, you should
only supply this argument if it's known that object-specific tests
are needed.

The list \code{.OldClassesList} contains the old-style classes that
are defined by the methods package.  Each element of the list is an
old-style list, with multiple character strings if inheritance is
included.
Each element of the list was passed to \code{setOldClass} when
creating the \pkg{methods} package; therefore, these classes can be used
in \code{\LinkA{setMethod}{setMethod}} calls, with the inheritance as implied by
the list.
\end{Details}
%
\begin{Section}{Extending S3 classes}
A call to \code{setOldClass} creates formal classes corresponding
to S3 classes, allows these to be used as slots in other classes or in
a signature in \code{\LinkA{setMethod}{setMethod}}, and mimics the S3
inheritance.

In documentation for the initial implementation of S4 classes in \R{},
users were warned against defining S4 classes that contained S3
classes, even if those had been registered.  The warning was based
mainly on two points.  1: The S3 behavior of the objects would fail
because the S3 class would not be visible, for example, when S3
methods are dispatched.  2: Because S3 classes have no formal
definition, nothing can be asserted in general about the S3 part of
an object from such a class.  (The warning was repeated as recently
as the first reference below.)

Nevertheless, defining S4 classes to contain an S3 class and extend
its behavior is attractive in many applications.  The alternative is
to be stuck with S3 programming, without the flexibility and security of
formal class and method definitions.

Beginning with version 2.8.0, \R{} provides support for extending
registered S3 classes; that is, for new classes defined by a call to
\code{\LinkA{setClass}{setClass}} in which the \code{contains=} argument
includes an S3 class.  See the examples below.  The support is aimed
primarily at providing the S3 class information for all classes that
extend class \LinkA{oldClass}{oldClass.Rdash.class}, in particular by ensuring that
all objects from such classes contain the S3 class in a special
slot.

There are three different ways to indicate an extension to an existing
S3 class:  \code{setOldClass()},  \code{setClass()} and
\code{setIs()}.  In most cases, calling \code{setOldClass} is the
best approach,  but the alternatives may be preferred in the special
circumstances described below.

Suppose \code{"A"} is any class extending \code{"oldClass"}. then

\code{setOldClass(c("B", "A"))} 

creates a new class \code{"B"} whose S3 class
concatenates \code{"B"}  with \code{S3Class("A")}.  The new class is a
virtual class.  If \code{"A"} was defined with known attribute/slots,
then \code{"B"} has these slots also; therefore, you must believe that
the corresponding S3 objects from class \code{"B"} do indeed have the
claimed attributes.  Notice that you can supply an S4 definition for the
new class to specify additional attributes (as described in the next
section.)
The first alternative call produces a non-virtual  class.

\code{setClass("B", contains = "A")}

This creates a non-virtual class with the same slots and superclasses
as class \code{"A"}.  However, class \code{"B"} is not included in
the S3 class slot of the new class, unless you provide it explicitly
in the prototype.

\code{setClass("B"); setIs("B", "A", .....)}

This creates a virtual class that extends \code{"A"}, but does not
contain the slots of \code{"A"}.  The additional arguments to
\code{\LinkA{setIs}{setIs}} should provide a coerce and replacement method.
In order for the new class to inherit S3 methods, the coerce method must
ensure that the class \code{"A"} object produced has a suitable S3
class.  The only likely reason to prefer this third approach is that
class \code{"B"} is not consistent with known attributes in class
\code{"A"}.

Beginning with version 2.9.0 of \R{}, objects from a class extending an
S3 class will be converted to the corresponding S3 class when being
passed to an S3 method defined for that class (that is, for one of the
strings in the S3 class attribute).  This is intended to ensure, as
far as possible, that such methods will work if they work for ordinary
S3 objects.  See \code{\LinkA{Classes}{Classes}} for details.


\end{Section}
%
\begin{Section}{S3 Classes with known attributes}
A further specification of an S3 class can be made \emph{if} the
class is guaranteed to have some attributes of known class (where as
with slots, ``known'' means that the attribute is an object of
a specified class, or a subclass of that class).

In this case, the call to \code{setOldClass()} can supply an S4 class
definition representing the known structure.  Since S4 slots are
implemented as attributes (largely for just this reason), the know
attributes can be specified in the representation of the S4 class.
The usual technique will be to create an S4 class with the desired
structure, and then supply the class name or definition as the
argument \code{S4Class} to \code{setOldClass()}. 

See the definition of class \code{"ts"} in the examples below.  The
call to \code{\LinkA{setClass}{setClass}} to create the S4 class can use the same class name, as here,
so long as the class definition is not sealed.  In the example, we
define \code{"ts"} as a vector structure with a numeric slot for
\code{"tsp"}.  The validity of this definition relies on an
assertion that all the S3 code for this class is consistent with
that definition; specifically, that all \code{"ts"} objects will
behave as vector structures and will have a numeric \code{"tsp"}
attribute. We  believe this to be true of all the base code in \R{},
but as always with S3 classes, no guarantee is possible.

The S4 class definition can  have virtual superclasses (as in
the \code{"ts"} case) if the S3 class is asserted to behave
consistently with these (in the example, time-series objects are
asserted to be consistent with the \LinkA{structure}{structure.Rdash.class} class).

For another example, look at the S4 class definition for \code{"data.frame"}.

Be warned that failures of the S3 class to live up to its asserted
behavior will usually go uncorrected, since S3 classes inherently
have no definition, and the resulting invalid S4 objects can cause
all sorts of grief.  Many S3 classes are not candidates for known
slots, either because the presence or class of the attributes are
not guaranteed  (e.g., \code{dimnames} in arrays, although these are
not even S3 classes), or because the class uses named components of
a list rather than attributes (e.g., \code{"lm"}).  An attribute
that is sometimes missing cannot be represented as a slot, not even
by pretending that it is present with class \code{"NULL"}, because
attributes unlike slots can not have value \code{NULL}.

One irregularity that is usually tolerated, however, is to
optionally add other attributes to those guaranteed to exist (for
example, \code{"terms"} in \code{"data.frame"} objects returned by
\code{\LinkA{model.frame}{model.frame}}).  As of version 2.8.0, validity checks by
\code{\LinkA{validObject}{validObject}} ignore extra attributes; even if this
check is tightened in the future, classes extending S3 classes
would likely be exempted because extra attributes are so common.

\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version: see section 10.6 for method
selection and section 13.4 for generic functions).

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{setClass}{setClass}}, \code{\LinkA{setMethod}{setMethod}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

require(stats)
setOldClass(c("mlm", "lm"))
setGeneric("dfResidual", function(model)standardGeneric("dfResidual"))
setMethod("dfResidual", "lm", function(model)model$df.residual)

## dfResidual will work on mlm objects as well as lm objects
myData <- data.frame(time = 1:10, y = (1:10)^.5)
myLm <- lm(cbind(y, y^3)  ~ time, myData)

## two examples extending S3 class "lm", class "xlm"  directly and "ylm" indirectly
setClass("xlm", representation(eps = "numeric"), contains = "lm")
setClass("ylm", representation(header = "character"), contains = "xlm")
ym1 = new("ylm", myLm, header = "Example", eps = 0.)
## for more examples, see ?\link{S3Class}.



## Examples of S3 classes with guaranteed attributes
## an S3 class "stamped" with a vector and  a "date" attribute
## Here is a generator function and an S3 print method.
## NOTE:  it's essential that the generator checks the attribute classes
stamped <- function(x, date = Sys.time()) {
    if(!inherits(date, "POSIXt"))
      stop("bad date argument")
    if(!is.vector(x))
      stop("x must be a vector")
    attr(x, "date") <- date
    class(x) <- "stamped"
    x
}

print.stamped <- function(x, ...) {
    print(as.vector(x))
    cat("Date: ",  format(attr(x,"date")), "\n")
}

## Now, an S4 class with the same structure:
setClass("stamped4", contains = "vector", representation(date = "POSIXt"))

## We can use the S4 class to register "stamped", with its attributes:
setOldClass("stamped", S4Class = "stamped4")
selectMethod("show", "stamped")
## and then remove "stamped4" to clean up
removeClass("stamped4")

someLetters <- stamped(sample(letters, 10),  ISOdatetime(2008, 10, 15, 12, 0, 0))

st <- new("stamped", someLetters)  
st  # show() method prints the object's class, then calls the S3 print method.

stopifnot(identical(S3Part(st, TRUE), someLetters))

# creating the S4 object directly from its data part and slots
new("stamped", 1:10, date = ISOdatetime(1976, 5, 5, 15, 10, 0))

## Not run: 
## The code in R that defines "ts" as an S4 class
setClass("ts", contains = "structure", 
      representation(tsp = "numeric"), 
      prototype(NA, tsp = rep(1,3))) # prototype to be a legal S3 time-series
## and now registers it as an S3 class
    setOldClass("ts", S4Class = "ts", where = envir)
 
## End(Not run)



\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{show}{Show an Object}{show}
\aliasA{show,ANY-method}{show}{show,ANY.Rdash.method}
\aliasA{show,classRepresentation-method}{show}{show,classRepresentation.Rdash.method}
\aliasA{show,genericFunction-method}{show}{show,genericFunction.Rdash.method}
\aliasA{show,MethodDefinition-method}{show}{show,MethodDefinition.Rdash.method}
\aliasA{show,MethodWithNext-method}{show}{show,MethodWithNext.Rdash.method}
\aliasA{show,ObjectsWithPackage-method}{show}{show,ObjectsWithPackage.Rdash.method}
\aliasA{show,traceable-method}{show}{show,traceable.Rdash.method}
\aliasA{show-methods}{show}{show.Rdash.methods}
\keyword{programming}{show}
%
\begin{Description}\relax
Display the object, by printing, plotting or whatever suits its
class.  This function exists to be specialized by methods.  The
default method calls \code{\LinkA{showDefault}{showDefault}}.

Formal methods for \code{show} will
usually be invoked for automatic printing (see the details).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
show(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] Any R object
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Objects from an S4 class (a class defined by a call to
\code{\LinkA{setClass}{setClass}}) will be displayed automatically is if by a
call to \code{show}.  S4 objects that occur as attributes of S3
objects will also be displayed in this form; conversely, S3 objects
encountered as slots in S4 objects will be printed using the S3
convention, as if by a call to \code{\LinkA{print}{print}}.

Methods defined for \code{show} will only be inherited  by simple
inheritance, since otherwise the method would not receive the
complete, original object, with misleading results.  See the
\code{simpleInheritanceOnly} argument to \code{\LinkA{setGeneric}{setGeneric}} and
the discussion in \code{\LinkA{setIs}{setIs}} for the general concept.

\end{Details}
%
\begin{Value}
\code{show} returns an invisible \code{NULL}.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{showMethods}{showMethods}} prints all the methods for one or more
functions;
\code{\LinkA{showMlist}{showMlist}} prints individual methods lists; 
\code{\LinkA{showClass}{showClass}} prints class definitions.
Neither of the latter two normally needs to be called directly.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## following the example shown in the setMethod documentation ...
setClass("track",
         representation(x="numeric", y="numeric"))
setClass("trackCurve", 
         representation("track", smooth = "numeric"))

t1 <- new("track", x=1:20, y=(1:20)^2)

tc1 <- new("trackCurve", t1)

setMethod("show", "track",
  function(object)print(rbind(x = object@x, y=object@y))
)
## The method will now be used for automatic printing of t1

t1

## Not run:   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
x    1    2    3    4    5    6    7    8    9    10    11    12
y    1    4    9   16   25   36   49   64   81   100   121   144
  [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20]
x    13    14    15    16    17    18    19    20
y   169   196   225   256   289   324   361   400

## End(Not run)
## and also for tc1, an object of a class that extends "track"
tc1

## Not run:   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
x    1    2    3    4    5    6    7    8    9    10    11    12
y    1    4    9   16   25   36   49   64   81   100   121   144
  [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20]
x    13    14    15    16    17    18    19    20
y   169   196   225   256   289   324   361   400

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{showMethods}{Show all the methods for the specified function(s)}{showMethods}
\keyword{methods}{showMethods}
%
\begin{Description}\relax
Show a summary of the methods for one or more generic functions,
possibly restricted to those involving specified classes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
showMethods(f = character(), where = topenv(parent.frame()),
            classes = NULL, includeDefs = FALSE,
            inherited = !includeDefs,
            showEmpty, printTo = stdout(), fdef =)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}] one or more function names.  If omitted, all functions
will be shown that match the other arguments.

The argument can also be an expression that evaluates to a single
generic function, in which
case argument \code{fdef} is ignored.  Providing an expression for
the function allows examination of hidden or anonymous functions;
see the example for \code{isDiagonal()}.
\item[\code{where}] Where to find the generic function, if not supplied as an
argument. When \code{f} is missing, or length 0, this also
determines which generic functions to examine.  If \code{where} is
supplied, only the generic functions returned by
\code{getGenerics(where)} are eligible for printing.  If
\code{where} is also missing, all the cached generic functions are
considered.
\item[\code{classes}] If argument \code{classes} is supplied, it is a vector
of class names that restricts the displayed results to those methods
whose signatures include one or more of those classes.
\item[\code{includeDefs}] If \code{includeDefs} is \code{TRUE}, include the
definitions of the individual methods in the printout.
\item[\code{inherited}] logical indicating if methods that have been found by
inheritance, so far in the session, will be included and marked as
inherited.  Note that an inherited method will not usually appear
until it has been used in this session.  See
\code{\LinkA{selectMethod}{selectMethod}} if you want to know what method would be
dispatched for particular classes of arguments.
\item[\code{showEmpty}] logical indicating whether methods with no defined
methods matching the other criteria should be shown at all.  By
default, \code{TRUE} if and only if argument \code{f} is not
missing.
\item[\code{printTo}] The connection on which the information will be
shown; by default, on standard output.
\item[\code{fdef}] Optionally, the generic function definition to use; if
missing, one is found, looking in \code{where} if that is specified.
See also comment in `Details'.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The name and package of the generic are followed by the list of
signatures for which methods are currently defined, according to the
criteria determined by the various arguments.  Note that the package
refers to the source of the generic function.  Individual methods
for that generic can come from other packages as well.

When more than one generic function is involved, either as specified or
because \code{f} was missing, the functions are found and
\code{showMethods} is recalled for each, including the generic as the
argument \code{fdef}.  In complicated situations, this can avoid some
anomalous results.
\end{Details}
%
\begin{Value}
If \code{printTo} is \code{FALSE}, the character vector that would
have been printed is returned; otherwise the value is the connection
or filename, via \code{\LinkA{invisible}{invisible}}.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{setMethod}{setMethod}}, and \code{\LinkA{GenericFunctions}{GenericFunctions}}
for other tools involving methods;
\code{\LinkA{selectMethod}{selectMethod}} will show you the method dispatched for a
particular function and signature of classes for the arguments.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
require(graphics)

## Assuming the methods for plot
## are set up as in the example of help(setMethod),
## print (without definitions) the methods that involve class "track":
showMethods("plot", classes = "track")
## Not run: 
# Function "plot":
# x = ANY, y = track
# x = track, y = missing
# x = track, y = ANY

require("Matrix")
showMethods("%*%")# many!
    methods(class = "Matrix")# nothing
showMethods(class = "Matrix")# everything
showMethods(Matrix:::isDiagonal) # a non-exported generic

## End(Not run)




not.there <- !any("package:stats4" == search())
if(not.there) library(stats4)
showMethods(classes = "mle")
if(not.there) detach("package:stats4")
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{signature-class}{Class "signature" For Method Definitions}{signature.Rdash.class}
\aliasA{show,signature-method}{signature-class}{show,signature.Rdash.method}
\keyword{classes}{signature-class}
%
\begin{Description}\relax
This class represents the mapping of some of the formal
arguments of a function onto the names of some classes.  It is used as
one of two slots in the \code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}} class.
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects can be created by calls of the form \code{new("signature",
    functionDef, ...)}.  The \code{functionDef} argument, if it is
supplied as a function object, defines the formal names.  The other
arguments define the classes.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] Object of class \code{"character"} the classes. 
\item[\code{names}:] Object of class \code{"character"} the
corresponding argument names. 

\end{description}

\end{Section}
%
\begin{Section}{Extends}
Class \code{"character"}, from data part.
Class \code{"vector"}, by class "character".
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[initialize] \code{signature(object = "signature")}: see the
discussion of objects from the class, above. 

\end{description}

\end{Section}
%
\begin{SeeAlso}\relax
class \code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}} for the use of this class.
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{slot}{The Slots in an Object from a Formal Class}{slot}
\aliasA{.slotNames}{slot}{.slotNames}
\aliasA{@<\Rdash}{slot}{@<.Rdash.}
\aliasA{getSlots}{slot}{getSlots}
\aliasA{slot<\Rdash}{slot}{slot<.Rdash.}
\aliasA{slotNames}{slot}{slotNames}
\keyword{programming}{slot}
\keyword{classes}{slot}
%
\begin{Description}\relax
These functions return or set information about the individual slots
in an object.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
object@name
object@name <- value

slot(object, name)
slot(object, name, check = TRUE) <- value

slotNames(x)
getSlots(x)

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] An object from a formally defined class.
\item[\code{name}] The name of the slot. The operator
takes a fixed name, which can be unquoted if it is syntactically a
name in the language.  A slot name can be any non-empty string, but
if the name is not made up of letters, numbers, and \code{.}, it
needs to be quoted (by backticks or single or double quotes).

In the case of the \code{slot} function, \code{name} can be any
expression that evaluates to a valid slot in the class definition.
Generally, the only reason to use the functional form rather than
the simpler operator is \emph{because} the slot name has to be computed.

\item[\code{value}] A new value for the named slot.  The value must be
valid for this slot in this object's class.
\item[\code{check}] In the replacement version of \code{slot}, a flag.  If
\code{TRUE}, check the assigned value for validity
as the value of this slot.  User's coded should not set this to
\code{FALSE} in normal use, since the resulting object can be invalid.

\item[\code{x}] either the name of a class (as character string), or a class
definition.  If given an argument that is neither a character string
nor a class definition, \code{slotNames} (only) uses \code{class(x)}
instead.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The definition of the class specifies all slots directly and
indirectly defined for that class.  Each slot has a name and an
associated class.  Extracting a slot returns an object from that
class.  Setting a slot first coerces the value to the specified slot
and then stores it.

Unlike general attributes, slots are not partially matched, and asking
for (or trying to set) a slot with an invalid name for that class
generates an error.

The \code{\LinkA{@}{@}} extraction operator and \code{slot}
function themselves do no checking against the class definition,
simply matching the name in the object itself.
The replacement forms do check (except for \code{slot} in the case
\code{check=FALSE}).  So long as slots are set without cheating, the
extracted slots will be valid.

Be aware that there are two ways to cheat, both to be avoided but
with no guarantees.  The obvious way is to assign a slot with
\code{check=FALSE}.  Also, slots in \R{} are implemented as
attributes, for the sake of some back compatibility.  The current
implementation does not prevent attributes being assigned, via
\code{\LinkA{attr<-}{attr<.Rdash.}}, and such assignments are not checked for
legitimate slot names.
\end{Details}
%
\begin{Value}
The \code{"@"} operator and the \code{slot} function extract or
replace the formally defined slots for the object.

Functions \code{slotNames} and \code{getSlots} return respectively the
names of the slots and the classes associated with the slots in the
specified class definition.  Except for its extended interpretation of
\code{x} (above), \code{slotNames(x)} is just \code{names(getSlots(x))}.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{@}{@}},
\code{\LinkA{Classes}{Classes}},
\code{\LinkA{Methods}{Methods}},
\code{\LinkA{getClass}{getClass}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}


setClass("track", representation(x="numeric", y="numeric"))
myTrack <- new("track", x = -4:4, y = exp(-4:4))
slot(myTrack, "x")
slot(myTrack, "y") <- log(slot(myTrack, "y"))
utils::str(myTrack)

getSlots("track") # or
getSlots(getClass("track"))
slotNames(class(myTrack)) # is the same as
slotNames(myTrack)


\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{StructureClasses}{Classes Corresponding to Basic Structures}{StructureClasses}
\aliasA{array-class}{StructureClasses}{array.Rdash.class}
\aliasA{initialize,array-method}{StructureClasses}{initialize,array.Rdash.method}
\aliasA{initialize,matrix-method}{StructureClasses}{initialize,matrix.Rdash.method}
\aliasA{initialize,mts-method}{StructureClasses}{initialize,mts.Rdash.method}
\aliasA{initialize,ts-method}{StructureClasses}{initialize,ts.Rdash.method}
\aliasA{Math,structure-method}{StructureClasses}{Math,structure.Rdash.method}
\aliasA{matrix-class}{StructureClasses}{matrix.Rdash.class}
\aliasA{Ops,array,array-method}{StructureClasses}{Ops,array,array.Rdash.method}
\aliasA{Ops,array,structure-method}{StructureClasses}{Ops,array,structure.Rdash.method}
\aliasA{Ops,structure,array-method}{StructureClasses}{Ops,structure,array.Rdash.method}
\aliasA{Ops,structure,structure-method}{StructureClasses}{Ops,structure,structure.Rdash.method}
\aliasA{Ops,structure,vector-method}{StructureClasses}{Ops,structure,vector.Rdash.method}
\aliasA{Ops,vector,structure-method}{StructureClasses}{Ops,vector,structure.Rdash.method}
\aliasA{show,ts-method}{StructureClasses}{show,ts.Rdash.method}
\aliasA{structure-class}{StructureClasses}{structure.Rdash.class}
\aliasA{ts-class}{StructureClasses}{ts.Rdash.class}
\keyword{classes}{StructureClasses}
%
\begin{Description}\relax
The virtual class \code{structure} and classes that
extend it are formal classes analogous to S language structures such
as arrays and time-series.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## The following class names can appear in method signatures,
## as the class in as() and is() expressions, and, except for
## the classes commented as VIRTUAL, in calls to new()

"matrix"
"array"
"ts"

"structure" ## VIRTUAL
\end{verbatim}
\end{Usage}
%
\begin{Section}{Objects from the Classes}
Objects can be created by calls of the form \code{new(Class, ...)},
where \code{Class} is the quoted name of the specific class (e.g.,
\code{"matrix"}), and the other arguments, if any, are interpreted as
arguments to the corresponding function, e.g., to function
\code{matrix()}.  There is no particular advantage over calling those
functions directly, unless you are writing software designed to work
for multiple classes, perhaps with the class name and the arguments
passed in.

Objects created from the classes \code{"matrix"} and \code{"array"} are unusual, to put
it mildly, and have been for some time.  Although they may appear to
be objects from these classes, they do not have the internal
structure of either an S3 or S4 class object.  In particular, they
have no \code{"class"} attribute and are not recognized as objects
with classes (that is, both \code{\LinkA{is.object}{is.object}} and
\code{\LinkA{isS4}{isS4}} will return \code{FALSE} for such objects).

That the objects still behave as if they came from the corresponding
class (most of the time, anyway) results from special code
recognizing such objects being built into the base code of \R{}.
For most purposes, treating the classes in the usual way will work,
fortunately.  One consequence of the special treatment is that these
two classes\emph{may} be used as the data part of an S4 class; for
example, you can get away with \code{contains = "matrix"} in a call
to \code{\LinkA{setGeneric}{setGeneric}} to create an S4 class that is a subclass
of \code{"matrix"}.  There is no guarantee that everything will work
perfectly, but a number of classes have been written in this form
successfully.

The class \code{"ts"}  is basically an S3 class
that has been registered with S4, using the
\code{\LinkA{setOldClass}{setOldClass}} mechanism.  Versions of \R{} through 2.7.0
treated this class as a pure S4 class, which was in principal a good
idea, but in practice did not allow subclasses to be defined and had
other intrinsic problems.  (For example, setting the
\code{"tsp"} parameters as a slot often fails because the built-in
implementation does not allow the slot to be temporarily
inconsistent with the length of the data. Also, the S4 class
prevented the correct specification of the S3 inheritance for class
\code{"mts"}.)

The current behavior (beginning with version 2.8.0 of \R{}) registers
\code{"ts"} as an S3 class,  using an S4-style definition (see the
documentation for \code{\LinkA{setOldClass}{setOldClass}} in the examples section
for an abbreviated listing of how this is done.  The S3
inheritance of \code{"mts"} in package \pkg{stats} is also
registered.
These classes, as well as \code{"matrix"} and \code{"array"} should
be valid in most examples as superclasses for new S4 class
definitions.



\end{Section}
%
\begin{Section}{Extends}
The specific classes all extend class \code{"structure"}, directly, and
class \code{"vector"}, by class \code{"structure"}.
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[coerce] Methods are defined to coerce arbitrary objects to
these classes, by calling the corresponding basic function, for
example, \code{as(x, "matrix")} calls \code{as.matrix(x)}.
If \code{strict = TRUE} in the call to \code{as()}, the method
goes on to delete all other slots and attributes other than the
\code{dim} and \code{dimnames}.

\item[Ops] Group methods (see, e.g., \code{\LinkA{S4groupGeneric}{S4groupGeneric}})
are defined for combinations of structures and vectors (including
special cases for array and matrix), implementing the concept of
vector structures as in the reference.  Essentially, structures
combined with vectors retain the structure as long as the
resulting object has the same length.  Structures combined with
other structures remove the structure, since there is no
automatic way to determine what should happen to the slots
defining the structure.

Note that these methods will be activated when a package is loaded
containing a class that inherits from any of the structure
classes or class \code{"vector"}.


\end{description}

\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)

Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
\emph{The New S Language}.
Wadsworth \& Brooks/Cole (for the original vector structures).
\end{References}
%
\begin{SeeAlso}\relax
Class \LinkA{nonStructure}{nonStructure.Rdash.class}, which enforces the
alternative model, in which all slots are dropped if any math
transformation or operation is applied to an object from a class extending one of
the basic classes.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
showClass("structure")

## explore a bit :
showClass("ts")
(ts0 <- new("ts"))
str(ts0)

showMethods("Ops") # six methods from these classes, but maybe many more
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{testInheritedMethods}{Test for and Report about  Selection of Inherited Methods}{testInheritedMethods}
\aliasA{.Other-class}{testInheritedMethods}{.Other.Rdash.class}
\aliasA{MethodSelectionReport-class}{testInheritedMethods}{MethodSelectionReport.Rdash.class}
\keyword{programming}{testInheritedMethods}
\keyword{classes}{testInheritedMethods}
\keyword{methods}{testInheritedMethods}
%
\begin{Description}\relax
A set of distinct inherited signatures is generated to test
inheritance for all the methods of a specified generic function.  If
method selection is ambiguous for some of these, a summary of the
ambiguities is attached to the returned object.  This test should be
performed by package authors \emph{before} releasing a package.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
testInheritedMethods(f, signatures, test = TRUE, virtual = FALSE,
                     groupMethods = TRUE, where = .GlobalEnv)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}] a generic function or the character string name of one.  By default,
all currently defined subclasses of all the method signatures for this
generic will be examined.  The other arguments are mainly options to
modify which inheritance patterns will be examined.

\item[\code{signatures}] 
An optional set of subclass signatures to use instead of the relevant
subclasses computed by \code{testInheritedMethods}.  See the Details
for how this is done.  This argument might be supplied after a call
with \code{test = FALSE}, to test selection in batches.

\item[\code{test}] 
optional flag to control whether method selection is actually tested.
If \code{FALSE}, returns just the list of relevant signatures for
subclasses, without calling \code{\LinkA{selectMethod}{selectMethod}} for each signature.
If there are a very large number of signatures, you may want to collect the full list  and then test them in batches.

\item[\code{virtual}] 
should virtual classes be included in the relevant subclasses.
Normally not, since only the classes of actual arguments will trigger
the inheritance calculation in a call to the generic function.
Including virtual classes may be useful if the class has no current
non-virtual subclasses but you anticipate your users may define such
classes in the future.

\item[\code{groupMethods}] 
should methods for the group generic function be included?

\item[\code{where}] 
the environment in which to look for class definitions.  Nearly
always, use the default global environment after attaching all the
packages with relevant methods and/or class definitions.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The following description applies when the optional arguments are
omitted, the usual case.
First, the defining signatures for all methods are computed by calls
to \code{\LinkA{findMethodSignatures}{findMethodSignatures}}.
From these all the known non-virtual subclasses are found for each
class that appears in the signature of some method.
These subclasses are split into groups according to which class they
inherit from, and only one subclass from each group is retained (for
each argument in the generic signature).
So if a method was defined with class \code{"vector"} for some
argument, one actual vector class is chosen arbitrarily.
The case of \code{"ANY"} is dealt with specially, since all classes
extend it.  A dummy, nonvirtual class, \code{".Other"}, is used to
correspond to all classes that have no superclasses among those being
tested.

All combinations of retained subclasses for the
arguments in the generic signature are then computed.
Each row of the resulting matrix is a signature to be tested by a call
to \code{\LinkA{selectMethod}{selectMethod}}.
To collect information on ambiguous selections,
\code{testInheritedMethods} establishes a calling handler for the
special signal \code{"ambiguousMethodSelection"}, by setting the
corresponding option.
\end{Details}
%
\begin{Value}
An object of class \code{"methodSelectionReport"}.  The details of
this class are currently subject to change.  It has slots
\code{"target"}, \code{"selected"}, \code{"candidates"}, and
\code{"note"}, all referring to the ambiguous cases (and so of length
0 if there were none).  These slots are intended to be examined by the
programmer to detect and preferably fix ambiguous method selections.
The object contains in addition slots \code{"generic"}, the name of
the generic function, and
\code{"allSelections"},  giving the vector of labels for all
the signatures tested.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (Section 10.6 for basics of method selection.)

Chambers, John M. (2009)
\emph{Class Inheritance in R}
\url{http://stat.stanford.edu/~jmc4/classInheritance.pdf} (to be
submitted to the R Journal).
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
## if no other attached  packages have methods for `+` or its group generic 
## functions, this returns a 16 by 2 matrix of selection patterns (in R 2.9.0)
testInheritedMethods("+")
\end{ExampleCode}
\end{Examples}
\inputencoding{latin1}
\HeaderA{TraceClasses}{Classes Used Internally to Control Tracing}{TraceClasses}
\aliasA{.doTracePrint}{TraceClasses}{.doTracePrint}
\aliasA{.InitTraceFunctions}{TraceClasses}{.InitTraceFunctions}
\aliasA{.makeTracedFunction}{TraceClasses}{.makeTracedFunction}
\aliasA{.untracedFunction}{TraceClasses}{.untracedFunction}
\aliasA{derivedDefaultMethodWithTrace-class}{TraceClasses}{derivedDefaultMethodWithTrace.Rdash.class}
\aliasA{functionWithTrace-class}{TraceClasses}{functionWithTrace.Rdash.class}
\aliasA{genericFunctionWithTrace-class}{TraceClasses}{genericFunctionWithTrace.Rdash.class}
\aliasA{groupGenericFunctionWithTrace-class}{TraceClasses}{groupGenericFunctionWithTrace.Rdash.class}
\aliasA{MethodDefinitionWithTrace-class}{TraceClasses}{MethodDefinitionWithTrace.Rdash.class}
\aliasA{MethodWithNextWithTrace-class}{TraceClasses}{MethodWithNextWithTrace.Rdash.class}
\aliasA{nonstandardGenericWithTrace-class}{TraceClasses}{nonstandardGenericWithTrace.Rdash.class}
\aliasA{traceable-class}{TraceClasses}{traceable.Rdash.class}
\keyword{classes}{TraceClasses}
%
\begin{Description}\relax
 The classes described  here are used by the R function
\code{\LinkA{trace}{trace}} to create versions of functions and methods
including browser calls, etc., and also to \code{\LinkA{untrace}{untrace}} the
same objects.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
### Objects from the following classes are generated
### by calling trace() on an object from the corresponding
### class without the "WithTrace" in the name.

"functionWithTrace"
"MethodDefinitionWithTrace"
"MethodWithNextWithTrace"
"genericFunctionWithTrace"
"groupGenericFunctionWithTrace"

### the following is a virtual class extended by each of the
### classes above

"traceable"
\end{verbatim}
\end{Usage}
%
\begin{Section}{Objects from the Class}
Objects will be created from these classes by calls to \code{trace}.
(There is an \code{\LinkA{initialize}{initialize}} method for class
\code{"traceable"}, but you are unlikely to need it directly.)
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] The data part, which will be \code{"function"}
for class \code{"functionWithTrace"}, and similarly for the other
classes.
\item[\code{original}:] Object of the original class; e.g.,
\code{"function"} for class \code{"functionWithTrace"}. 

\end{description}

\end{Section}
%
\begin{Section}{Extends}
Each of the classes extends the corresponding untraced class, from the
data part; e.g., \code{"functionWithTrace"} extends \code{"function"}.
Each of the specific classes extends \code{"traceable"}, directly,
and class \code{"VIRTUAL"}, by class \code{"traceable"}.
\end{Section}
%
\begin{Section}{Methods}
The point of the specific classes is that objects generated from them,
by function \code{trace()}, remain callable or dispatchable, in
addition to their new trace information.
\end{Section}
%
\begin{SeeAlso}\relax
 function \code{\LinkA{trace}{trace}} 
\end{SeeAlso}
\inputencoding{latin1}
\HeaderA{validObject}{Test the Validity of an Object}{validObject}
\aliasA{getValidity}{validObject}{getValidity}
\aliasA{setValidity}{validObject}{setValidity}
\keyword{programming}{validObject}
\keyword{classes}{validObject}
%
\begin{Description}\relax
The validity of \code{object} related to its class definition is
tested.  If the object is valid, \code{TRUE} is returned; otherwise,
either a vector of strings describing validity failures is returned,
or an error is generated (according to whether \code{test} is
\code{TRUE}).  Optionally, all slots in the object can also be validated.

The function \code{setValidity} sets the validity method of a class
(but more normally, this method will be supplied as the
\code{validity} argument to \code{\LinkA{setClass}{setClass}}).  The method
should be a function of one object that returns \code{TRUE} or a
description of the non-validity.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
validObject(object, test = FALSE, complete = FALSE)

setValidity(Class, method, where = topenv(parent.frame()) )

getValidity(ClassDef)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}]  any object, but not much will happen unless the
object's class has a formal definition.
\item[\code{test}] logical; if \code{TRUE} and validity fails, the
function returns a vector of strings describing the problems.  If
\code{test} is \code{FALSE} (the default) validity failure generates
an error.
\item[\code{complete}] logical; if \code{TRUE}, validity methods will be
applied recursively to any of the slots that have such methods.
\item[\code{Class}] the name or class definition of the class whose validity
method is to be set.
\item[\code{ClassDef}] a class definition object, as from
\code{\LinkA{getClassDef}{getClassDef}}.
\item[\code{method}] a validity method;  that is, either \code{NULL} or a
function of one argument (\code{object}).  Like
\code{validObject}, the function should return \code{TRUE} if the
object is valid, and one or more descriptive strings if any problems
are found.  Unlike \code{validObject}, it should never generate an
error.

\item[\code{where}] the modified class definition will be stored in this
environment.

Note that validity methods do not have to check validity of
superclasses: the logic of \code{validObject} ensures these tests are
done once only.  As a consequence, if one validity method wants to use
another, it should extract and call the method from the other
definition of the other class by calling \code{getValidity()}: it
should \emph{not} call \code{validObject}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Validity testing takes place `bottom up': Optionally, if
\code{complete=TRUE}, the validity of the object's slots, if any, is
tested.  Then, in all cases, for each of the classes that this class
extends (the `superclasses'), the explicit validity method of
that class is called, if one exists.  Finally, the validity method of
\code{object}'s class is called, if there is one.

Testing generally stops at the first stage of finding an error, except
that all the slots will be examined even if a slot has failed its
validity test.

The standard validity test (with \code{complete=FALSE}) is applied
when an object is created via \code{\LinkA{new}{new}} with any optional
arguments (without the extra arguments the result is just the class
prototype object).

An attempt is made to fix up the definition of a validity method if
its argument is not \code{object}.
\end{Details}
%
\begin{Value}
\code{validObject} returns \code{TRUE} if the object is valid.
Otherwise a vector of strings describing problems found, except that
if \code{test} is \code{FALSE}, validity failure generates an error,
with the corresponding strings in the error message.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.) 
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{setClass}{setClass}};
class \code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
setClass("track",
          representation(x="numeric", y = "numeric"))
t1 <- new("track", x=1:10, y=sort(stats::rnorm(10)))
## A valid "track" object has the same number of x, y values
validTrackObject <- function(object) {
    if(length(object@x) == length(object@y)) TRUE
    else paste("Unequal x,y lengths: ", length(object@x), ", ",
               length(object@y), sep="")
}
## assign the function as the validity method for the class
setValidity("track", validTrackObject)
## t1 should be a valid "track" object
validObject(t1)
## Now we do something bad
t2 <- t1
t2@x <- 1:20
## This should generate an error
## Not run: try(validObject(t2))


setClass("trackCurve",
         representation("track", smooth = "numeric"))

## all superclass validity methods are used when validObject
## is called from initialize() with arguments, so this fails
## Not run: trynew("trackCurve", t2)


setClass("twoTrack", representation(tr1 = "track", tr2 ="track"))

## validity tests are not applied recursively by default,
## so this object is created (invalidly)
tT  <- new("twoTrack", tr2 = t2)

## A stricter test detects the problem
## Not run: try(validObject(tT, complete = TRUE))

\end{ExampleCode}
\end{Examples}
\clearpage
